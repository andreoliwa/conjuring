{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Conjuring","text":"<p>Reusable global Invoke tasks that can be merged with local project tasks.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Merge any local <code>tasks.py</code> file with global Conjuring tasks</li> <li>Use all global Conjuring tasks provided by this package</li> <li>Only include the global Conjuring tasks you want (opt-in mode)</li> <li>Use all Conjuring tasks excluding some (opt-out mode)</li> <li>Add your own custom tasks from Python modules or packages to global tasks</li> <li>Display your custom task modules conditionally</li> <li>Display your custom individual tasks conditionally</li> <li>Merge your project tasks with the global reusable tasks</li> <li>Prefix task names of your custom module</li> </ul> <p>More details on the features documentation.</p>"},{"location":"#tasks","title":"Tasks","text":"<p>Each module under the <code>conjuring/spells</code> directory is a collection of Invoke tasks.</p> <p>Read more in Spells (API reference).</p>"},{"location":"#quick-setup","title":"Quick setup","text":"<p>Install Conjuring in an isolated virtualenv with pipx:</p> <pre><code>pipx install --include-deps conjuring\n</code></pre> <p>The <code>--include-deps</code> flag is needed to install Invoke's apps (<code>invoke</code> and <code>inv</code>).</p> <p>Run the command to configure files on your home directory:</p> <pre><code># For more options:\n# conjuring init --help\nconjuring init\n</code></pre> <p>You should see the list of Conjuring tasks from any directory where you type this:</p> <pre><code>invoke --list\n</code></pre> <p>For more configuration options, read the detailed documentation.</p>"},{"location":"CHANGELOG/","title":"Changelog","text":""},{"location":"CHANGELOG/#v070-2023-05-27","title":"v0.7.0 (2023-05-27)","text":""},{"location":"CHANGELOG/#feat","title":"Feat","text":"<ul> <li>\"conjuring init\" command to set up files (#11)</li> <li>py: -s option in py.test and py.coverage</li> </ul>"},{"location":"CHANGELOG/#fix","title":"Fix","text":"<ul> <li>git: improve commit body clean-up</li> </ul>"},{"location":"CHANGELOG/#v060-2023-05-24","title":"v0.6.0 (2023-05-24)","text":""},{"location":"CHANGELOG/#feat_1","title":"Feat","text":"<ul> <li>direnv: command to init .envrc</li> </ul>"},{"location":"CHANGELOG/#refactor","title":"Refactor","text":"<ul> <li>replace print() by typer.echo()</li> <li>add typing to py and remaining tests</li> <li>add typing to mkdocs, mr, onedrive, paperless, pre-commit</li> <li>add typing and docs to some modules</li> </ul>"},{"location":"CHANGELOG/#v050-2023-05-22","title":"v0.5.0 (2023-05-22)","text":""},{"location":"CHANGELOG/#feat_2","title":"Feat","text":"<ul> <li>add global tasks from Python modules or packages</li> </ul>"},{"location":"CHANGELOG/#fix_1","title":"Fix","text":"<ul> <li>py: always show ruff-config even on non-Poetry projects</li> <li>improved messages on conjuring.init</li> </ul>"},{"location":"CHANGELOG/#v040-2023-05-21","title":"v0.4.0 (2023-05-21)","text":""},{"location":"CHANGELOG/#feat_3","title":"Feat","text":"<ul> <li>py: task to generate Ruff config from warnings</li> </ul>"},{"location":"CHANGELOG/#v030-2023-05-20","title":"v0.3.0 (2023-05-20)","text":""},{"location":"CHANGELOG/#feat_4","title":"Feat","text":"<ul> <li>choose which tasks you want to load (opt-in/opt-out)</li> </ul>"},{"location":"CHANGELOG/#v021-2023-05-20","title":"v0.2.1 (2023-05-20)","text":""},{"location":"CHANGELOG/#fix_2","title":"Fix","text":"<ul> <li>version number and project metadata</li> </ul>"},{"location":"CHANGELOG/#v020-2023-05-19","title":"v0.2.0 (2023-05-19)","text":""},{"location":"CHANGELOG/#fix_3","title":"Fix","text":"<ul> <li>read pyproject.toml with UTF-8 encoding</li> </ul>"},{"location":"CHANGELOG/#010-2023-05-19","title":"0.1.0 (2023-05-19)","text":""},{"location":"CHANGELOG/#feat_5","title":"Feat","text":"<ul> <li>media: transcribe using whisper</li> <li>mkdocs: tasks to work with documentation</li> <li>k8s: select multiple apps at once</li> <li>k8s: get pods, replica sets, config maps + validate score</li> <li>mr: add mr support, grep repos for a search text</li> <li>pre-commit: specify hooks without --hook</li> <li>python: test, watch, coverage, debug tools</li> <li>git: option to rebase master branch</li> <li>python: install/reinstall specific version</li> <li>fzf: accept options as arguments</li> <li>aws: list profiles</li> <li>allowed keys in ask_user_prompt()</li> <li>onedrive: display files with conflicts</li> <li>media: --force flag to delete files</li> <li>python: install a Poetry virtual environment</li> <li>paperless: delete failed duplicates</li> <li>remove hidden files and empty dirs</li> <li>paperless: move files instead of copying</li> <li>paperless: skip years and .DS_Store</li> <li>paperless: copy matched/unmatched files to ~/Downloads</li> <li>paperless: display orphan files, matched and unmatched</li> <li>paperless: show matched/unmatched files</li> <li>paperless: show thumbnails</li> <li>paperless: wrapper tasks for paperless</li> <li>ask user prompt</li> <li>git: prepare commit body with bullets</li> <li>git: task to tidy up repo</li> <li>pre-commit: install prepare-commit-msg</li> <li>pre-commit: uninstall all hooks</li> <li>slideshow command (first version)</li> <li>git: watch build then open PR or repo</li> <li>use AWS_PROFILE if it exists</li> <li>git: display changes since the chosen tag</li> <li>pre-commit: commit-msg hook is now optional</li> <li>shell: list and uninstall shell completions</li> <li>shell: click completion for Bash</li> <li>git: choose files with fzf, allow multiple subdirs</li> <li>download video URLs with youtube-dl</li> <li>git: merge the default branch of the repo</li> <li>git: options to rewrite commits with GPG and author</li> <li>docker: remove Docker containers and volumes</li> <li>todo: sort by type+description, option to show only FIXME</li> <li>list TODOs and FIXMEs in code</li> <li>pre-commit: accept comma-separated list of hooks to run</li> <li>git: extract files from a subtree + history + rebase/sign</li> <li>support PEP 660 hooks (editable packages)</li> <li>empty module for those who don't want the default tasks</li> <li>AWS: select account, region, ECR, aws-vault</li> <li>pre-commit: command to uninstall hooks</li> <li>poetry: choose pipx repo to inject with fzf</li> <li>display individual tasks conditionally</li> <li>visibility.py module with reusable functions</li> <li>prefix task names of a module</li> <li>display tasks conditionally</li> <li>merge any tasks.py with Conjuring tasks</li> <li>pre-commit: autoupdate one or all hooks</li> <li>use CONJURING_PREFIX to namespace tasks</li> <li>install a Poetry package as editable</li> <li>default module with all conjuring tasks</li> <li>fork tasks in a separate module</li> <li>optionally check empty dirs</li> <li>display dirs that should be emptied</li> <li>duplicity: choose a directory when restoring</li> <li>backup/restore with Duplicity</li> <li>onedrive: current year first, then others</li> <li>list dirs with _Copy files</li> <li>unhide Picasa originals dir</li> <li>merge original dirs</li> <li>merge copy dirs</li> <li>move picture dirs by year</li> <li>backup files from the m3 hard drive</li> <li>list more dirs on OneDrive</li> <li>add warn param to run_command()</li> <li>option to choose journal on tags task</li> <li>remove empty files before OneDrive dir</li> <li>open the latest N OneDrive photo dirs</li> <li>function to run with fzf</li> <li>run_command function</li> <li>ignore modules with an env var</li> <li>jrnl: journal name</li> <li>more Git helpers</li> <li>query jrnl entries and tags</li> <li>configure a generic remote</li> <li>don't add home tasks twice</li> <li>auto update nitpick</li> <li>set SSH/HTTPS URL for remote</li> <li>pre-commit install and run</li> <li>fork remote and sync</li> <li>invoke tasks for home/current dirs</li> <li>change invoke collection name</li> </ul>"},{"location":"CHANGELOG/#fix_4","title":"Fix","text":"<ul> <li>pre-commit: don't stop on the first failed hook</li> <li>deps: update dependency requests to v2.30.0</li> <li>deps: update dependency invoke to v2.1.2</li> <li>py: check lock before installing, ignore comment on version</li> <li>py: don't fail if pyenv local is not set</li> <li>git: rebase with force push, from origin</li> <li>rename to py, use venv after pyenv set local</li> <li>media: use -f as short for --force</li> <li>return user input on ask_user_prompt()</li> <li>paperless: ignore all .DS_Store, fix --together</li> <li>paperless: don't display red files that can't be checked</li> <li>git: regex to parse Jira tickets</li> <li>git: body cleanup: Jira ticket and other stuff</li> <li>duplicity: max depth when running fd in OneDrive dirs</li> <li>duplicity: uppercase $HOME</li> <li>git: shorten names for commit body command</li> <li>git: prune after deleting branches, push by default</li> <li>media: open the last file (order was random before)</li> <li>git: prune remotes before updating the repo</li> <li>git: open PR in same branch that was watched</li> <li>improved Poetry detection (#1)</li> <li>organize: call invoke task and not the tool directly</li> <li>fd flags (hidden only)</li> <li>display Conjuring tasks only on home dir</li> <li>duplicated name in main collection</li> <li>check prefix before duplicated tasks</li> <li>dry-run mode on run_command()</li> <li>remote name defaults to username</li> <li>duplicity: restore on computer subdir</li> <li>check both Telegram dirs</li> <li>move Telegram dir under Samsung Gallery</li> <li>rename organize to categorize</li> <li>convert Path to str when joining</li> <li>show Telegram dir after current year dir</li> <li>don't limit jrnl entries by default</li> <li>jrnl improvements</li> <li>allow invoke*.py files</li> <li>pty=False to remove colors</li> </ul>"},{"location":"CHANGELOG/#refactor_1","title":"Refactor","text":"<ul> <li>constants for common directories</li> <li>prefer qualified imports (#3)</li> <li>preparing for multiple spell books</li> <li>gita_super is a better name</li> <li>a more appropriate name</li> <li>move tasks to their spell modules</li> <li>move color constants to conjuring</li> <li>create package structure</li> </ul>"},{"location":"features/","title":"Features","text":""},{"location":"features/#modes","title":"Modes","text":"<p>Conjuring has 3 available modes (all tasks, opt-in and opt-out), detailed below.</p> <p>When you run <code>conjuring init</code>, it creates an <code>~/.invoke.yaml</code> file and a <code>~/conjuring_init.py</code> on your home directory.</p> <p>This will merge any existing local <code>tasks.py</code> file with the global Conjuring tasks.</p> <p>For more details, read about default configuration values on Configuration \u2014 Invoke documentation.</p>"},{"location":"features/#all-tasks","title":"All tasks","text":"<p>To use all global Conjuring tasks provided by this package, run:</p> <pre><code>conjuring init --mode all\n</code></pre> <p>Run <code>invoke --list</code> from any directory, and you will see all Conjuring tasks.</p>"},{"location":"features/#opt-in","title":"Opt-in","text":"<p>If you want to only include the global Conjuring tasks you want, run this command and select the files with fzf:</p> <pre><code>conjuring init --mode opt-in\n</code></pre> <p>Or you can edit the Python bootstrap file manually. Suppose you only want these global tasks:</p> <ul> <li>AWS;</li> <li>Kubernetes;</li> <li>pre-commit;</li> <li>Python;</li> <li>all tasks that install anything.</li> </ul> <p>This is how you can do it:</p> <pre><code># ~/conjuring_init.py\nfrom conjuring import Spellbook\nnamespace = Spellbook().cast_only(\"aws*\", \"k8s*\", \"pre-commit*\", \"py*\", \"*install\")\n</code></pre>"},{"location":"features/#opt-out","title":"Opt-out","text":"<p>To use all Conjuring modules and tasks, except for a few, run this command and select the files with fzf:</p> <pre><code>conjuring init --mode opt-out\n</code></pre> <p>Or you can edit the Python bootstrap file manually.</p> <p>Suppose you want all Conjuring tasks except media and OneDrive tasks. This is the way:</p> <pre><code># ~/conjuring_init.py\nfrom conjuring import Spellbook\nnamespace = Spellbook().cast_all_except(\"media*\", \"onedrive*\")\n</code></pre>"},{"location":"features/#shell-enhancements","title":"Shell enhancements","text":"<p>Invoke can also be configured with environment variables for an even smoother experience.</p> <p>Note: this is not a Conjuring feature, it's built-in in Invoke.</p>"},{"location":"features/#echo-all-commands","title":"Echo all commands","text":"<p>Echo all commands in all tasks by default, like Make does.</p> <pre><code># ~/.bashrc, ~/.zshrc or your favourite shell\nexport INVOKE_RUN_ECHO=1\n</code></pre> <p>Docs</p> <p> Environment variables: Basic rules \u2014 Invoke documentation.</p>"},{"location":"features/#coloured-output","title":"Coloured output","text":"<p>Use a pseudo-terminal by default (display colored output):</p> <pre><code># ~/.bashrc, ~/.zshrc or your favourite shell\nexport INVOKE_RUN_PTY=1\n</code></pre> <p>Docs</p> <p> runners \u2014 Invoke documentation.</p>"},{"location":"features/#short-aliases","title":"Short aliases","text":"<p>Add short aliases for the <code>invoke</code> command:</p> <pre><code># ~/.bashrc, ~/.zshrc or your favourite shell\nalias i='invoke'\nalias il='invoke --list'\nalias ih='invoke --help'\nalias ir='invoke --dry'\n</code></pre>"},{"location":"features/#auto-completion","title":"Auto-completion","text":"<p>Follow this quick copy/paste setup to configure auto-completion for Conjuring. Or read the links below for more details.</p> <p>To enable completion on terminals, add this to your <code>~/.bash_profile</code>:</p> <pre><code># ~/.bash_profile\nexport BASH_COMPLETION_USER_DIR=\"$HOME/.local/share/bash-completion\"\nif [[ -d \"$BASH_COMPLETION_USER_DIR/completions\" ]]; then\nfor COMPLETION in \"$BASH_COMPLETION_USER_DIR/completions/\"*; do\nsource \"$COMPLETION\"\ndone\nfi\n# https://github.com/tiangolo/typer installs completion files in this directory\nif [[ -d \"$HOME/.bash_completions/\" ]]; then\nfor COMPLETION in \"$HOME/.bash_completions/\"*; do\n[[ -r \"$COMPLETION\" ]] &amp;&amp; source \"$COMPLETION\"\ndone\nfi\n</code></pre> <p>Then run these commands to install auto-completion for Invoke and Conjuring:</p> <pre><code># To get help, run `invoke` or `invoke --help`\ninvoke --print-completion-script=bash &gt; $BASH_COMPLETION_USER_DIR/completions/invoke.bash-completion\n\n# To get help, run `conjuring` or `conjuring --help`\nconjuring --install-completion bash\n</code></pre> <p>Then open a new terminal, type <code>invoke &lt;TAB&gt;</code> or <code>conjuring &lt;TAB&gt;</code>, and you will have auto-completion.</p> <p>You can even set up auto-completion for aliases (like <code>i &lt;TAB&gt;</code> for <code>invoke</code>) with the complete-alias project.</p> <p>Some links for more details:</p> <ul> <li>Shell tab completion \u2014 Invoke documentation</li> <li>scop/bash-completion: Programmable completion functions for bash</li> <li>cykerway/complete-alias: automagical shell alias completion;</li> </ul>"},{"location":"features/#creating-your-own-reusable-tasks","title":"Creating your own reusable tasks","text":""},{"location":"features/#add-your-own-custom-tasks-from-python-modules-or-packages-to-global-tasks","title":"Add your own custom tasks from Python modules or packages to global tasks","text":"<p>You can create your own Python modules or packages with Invoke tasks, and they can be added to the global scope and be available from any directory.</p> <ul> <li>On the init file, call <code>import_dirs()</code> with the path to your modules or packages;</li> <li>The import method detects if the directory is a Python package or not,   and imports it accordingly;</li> <li>The example uses <code>cast_all()</code>, but you can use any of the other <code>cast_*</code>   methods described above (opt-in   or opt-out).</li> </ul> <pre><code># ~/conjuring_init.py\nfrom conjuring import Spellbook\nnamespace = (\nSpellbook()\n.import_dirs(\n\"~/path/to/your/src/my_package\",\n\"~/path/to/a/some-directory-with-py-files\",\n)\n.cast_all()\n)\n</code></pre>"},{"location":"features/#display-your-custom-task-modules-conditionally","title":"Display your custom task modules conditionally","text":"<p>Some modules under the <code>spells</code> directory have a <code>should_display_tasks</code> boolean function to control whether the tasks are displayed or not.</p> <p>The <code>conjuring.visibility</code> module has boolean functions that can be reused by your modules and tasks.</p> <p>Example from the <code>conjuring.spells.git</code> module:</p> <pre><code># /path/to/your_task_module.py\nfrom conjuring.visibility import is_git_repo, ShouldDisplayTasks\nshould_display_tasks: ShouldDisplayTasks = is_git_repo\n</code></pre> <p>Other use cases:</p> <ul> <li>Poetry tasks: display only when   there is a <code>pyproject.toml</code> in the current dir;</li> <li>pre-commit tasks: display only   when there is a <code>.pre-commit-config.yaml</code> file in the current dir.</li> </ul>"},{"location":"features/#display-your-custom-individual-tasks-conditionally","title":"Display your custom individual tasks conditionally","text":"<p>A task can have its own visibility settings, even if the owner module is configured to not display tasks.</p> <pre><code># /path/to/another_task_module.py\nfrom invoke import task\nfrom conjuring.visibility import MagicTask\nfrom random import randint\n@task(klass=MagicTask)\ndef an_always_visible_task(c):\n\"\"\"A MagicTask is always visible by default.\n    It will always be displayed in every directory,\n        regardless of the module ``should_display_tasks()`` function.\n    \"\"\"\npass\n@task(klass=MagicTask, should_display=lambda: bool(randint(0, 1)))\ndef a_conditionally_visible_task(c):\n\"\"\"You can use any boolean function to determine visibility.\"\"\"\npass\n</code></pre> <p>Use case:</p> <ul> <li>you want to group tasks in a module, with a prefix and conditional display of tasks;</li> <li>you still want some individual tasks to always be displayed;</li> <li>or you want different conditions to display certain tasks.</li> </ul>"},{"location":"features/#merge-your-project-tasks-with-the-global-reusable-tasks","title":"Merge your project tasks with the global reusable tasks","text":"<p>Create local <code>conjuring*.py</code> files, and they will be merged with the <code>tasks.py</code> in your home dir. Your project dir can be anywhere under your home dir.</p> <p>Create two modules with Invoke tasks:</p> <pre><code># ~/path/to/project/conjuring_foo.py\nfrom invoke import task\n@task\ndef my_foo(c):\n\"\"\"My foo task.\"\"\"\npass\n# ~/path/to/project/conjuring_bar.py\nfrom invoke import task\n@task\ndef my_bar(c):\n\"\"\"My bar task.\"\"\"\npass\n</code></pre> <p>The task list in your project dir will show tasks from all files, including the home dir task list.</p> <pre><code>$ cd ~/path/to/project/\n$ invoke --list\nAvailable tasks:\n\nmy-bar               My bar task.\n my-foo               My foo task.\n &lt;... the global Conjuring tasks will show up here...&gt;\n</code></pre>"},{"location":"features/#prefix-task-names-of-your-custom-module","title":"Prefix task names of your custom module","text":"<p>If the module defines this boolean constant with a value of <code>True</code>, then the name of the module will be added as a prefix to tasks.</p> <p>Example for the <code>conjuring.spells.pre_commit</code> module:</p> <pre><code>SHOULD_PREFIX = True\n</code></pre> <p>All the tasks of this module will have a <code>pre-commit.</code> prefix when you run <code>invoke --list</code>.</p>"},{"location":"related/","title":"Related projects","text":"<ul> <li>pyinvoke/invoke: Pythonic task management &amp; command execution.</li> <li>pyinvoke/invocations: Reusable Invoke tasks</li> <li>jhermann/rituals: Project automation task library for \u2018Invoke\u2019 tasks that are needed again and again.</li> </ul>"},{"location":"spells/","title":"Spells (API reference)","text":"<p>This is an API reference for the all the Invoke tasks and helper functions that are included in the Conjuring package.</p>"},{"location":"spells/#conjuring.spells.aws","title":"<code>conjuring.spells.aws</code>","text":"<p>AWS: ECR login.</p>"},{"location":"spells/#conjuring.spells.aws.clean_ecr_url","title":"<code>clean_ecr_url(c, url=None)</code>","text":"<p>Clean an AWS ECR URL.</p> Source code in <code>src/conjuring/spells/aws.py</code> <pre><code>def clean_ecr_url(c: Context, url: Optional[str] = None) -&gt; str:\n\"\"\"Clean an AWS ECR URL.\"\"\"\nif not url:\naccount = fzf_aws_account(c)\nregion = fzf_aws_region(c)\nreturn f\"{account}.dkr.ecr.{region}.amazonaws.com\"\nreturn urlparse(url).netloc\n</code></pre>"},{"location":"spells/#conjuring.spells.aws.ecr_login","title":"<code>ecr_login(c, url='')</code>","text":"<p>Log in to AWS ECR.</p> <p>Using Amazon ECR with the AWS CLI - Amazon ECR</p> Source code in <code>src/conjuring/spells/aws.py</code> <pre><code>@task\ndef ecr_login(c: Context, url: str = \"\") -&gt; None:\n\"\"\"Log in to AWS ECR.\n    [Using Amazon ECR with the AWS CLI - Amazon ECR](https://docs.aws.amazon.com/AmazonECR/latest/userguide/getting-started-cli.html#cli-authenticate-registry)\n    \"\"\"\nprofile = fzf_aws_profile(c)\nurl = clean_ecr_url(c, url)\nrun_command(\nc,\n\"aws ecr get-login-password --profile\",\nprofile,\n\"| docker login --username AWS --password-stdin\",\nurl,\n)\n</code></pre>"},{"location":"spells/#conjuring.spells.aws.fzf_aws_account","title":"<code>fzf_aws_account(c)</code>","text":"<p>Select an AWS account from the config file.</p> Source code in <code>src/conjuring/spells/aws.py</code> <pre><code>def fzf_aws_account(c: Context) -&gt; str:\n\"\"\"Select an AWS account from the config file.\"\"\"\nreturn run_with_fzf(c, f\"rg -o 'aws:iam::[^:]+' {AWS_CONFIG} | cut -d ':' -f 4 | sort -u\")\n</code></pre>"},{"location":"spells/#conjuring.spells.aws.fzf_aws_profile","title":"<code>fzf_aws_profile(c, partial_name=None)</code>","text":"<p>Select an AWS profile from a partial profile name using fzf.</p> Source code in <code>src/conjuring/spells/aws.py</code> <pre><code>def fzf_aws_profile(c: Context, partial_name: Optional[str] = None) -&gt; str:\n\"\"\"Select an AWS profile from a partial profile name using fzf.\"\"\"\nif not partial_name and (aws_profile := os.environ.get(\"AWS_PROFILE\")) and aws_profile:\ntyper.echo(f\"Using env variable AWS_PROFILE (set to '{aws_profile}')\")\nreturn aws_profile\nreturn run_with_fzf(c, LIST_AWS_PROFILES_COMMAND, query=partial_name or \"\")\n</code></pre>"},{"location":"spells/#conjuring.spells.aws.fzf_aws_region","title":"<code>fzf_aws_region(c)</code>","text":"<p>Select an AWS region from the config file.</p> Source code in <code>src/conjuring/spells/aws.py</code> <pre><code>def fzf_aws_region(c: Context) -&gt; str:\n\"\"\"Select an AWS region from the config file.\"\"\"\nreturn run_with_fzf(c, f\"rg -o '^region.+' {AWS_CONFIG} | tr -d ' ' | cut -d'=' -f 2 | sort -u\")\n</code></pre>"},{"location":"spells/#conjuring.spells.aws.list_aws_profiles","title":"<code>list_aws_profiles(c)</code>","text":"<p>List AWS profiles from the config file.</p> Source code in <code>src/conjuring/spells/aws.py</code> <pre><code>def list_aws_profiles(c: Context) -&gt; list[str]:\n\"\"\"List AWS profiles from the config file.\"\"\"\nreturn run_lines(c, LIST_AWS_PROFILES_COMMAND)\n</code></pre>"},{"location":"spells/#conjuring.spells.aws.run_aws_vault","title":"<code>run_aws_vault(c, *pieces, profile=None)</code>","text":"<p>Run AWS vault commands in a subshell, or open a subshell if no commands were provided.</p> Source code in <code>src/conjuring/spells/aws.py</code> <pre><code>def run_aws_vault(c: Context, *pieces: str, profile: Optional[str] = None) -&gt; Result:\n\"\"\"Run AWS vault commands in a subshell, or open a subshell if no commands were provided.\"\"\"\nreturn run_command(c, \"aws-vault exec\", fzf_aws_profile(c, profile), \"--\", *pieces, pty=False)\n</code></pre>"},{"location":"spells/#conjuring.spells.direnv","title":"<code>conjuring.spells.direnv</code>","text":"<p>direnv: init local dir.</p>"},{"location":"spells/#conjuring.spells.direnv.init","title":"<code>init(c, source_up=False, dotenv=False, all_=False)</code>","text":"<p>Configure direnv in the local dir.</p> Source code in <code>src/conjuring/spells/direnv.py</code> <pre><code>@task()\ndef init(c: Context, source_up: bool = False, dotenv: bool = False, all_: bool = False) -&gt; None:\n\"\"\"Configure direnv in the local dir.\"\"\"\nif all_:\nsource_up = dotenv = True\nif not (source_up or dotenv or all_):\nprint_error(\"Choose one of the options: --source-up, --dotenv, --all\")\nreturn\nenvrc = Path(ENVRC)\ncontent = envrc.read_text() if envrc.exists() else \"\"\nif source_up and SOURCE_UP_IF_EXISTS not in content:\ncontent += SOURCE_UP_IF_EXISTS_TEMPLATE\nif dotenv and DOTENV_IF_EXISTS not in content:\ncontent += DOTENV_IF_EXISTS_TEMPLATE\nif content:\nenvrc.write_text(content)\nc.run(\"direnv allow\")\nbat(c, \".env*\")\n</code></pre>"},{"location":"spells/#conjuring.spells.docker","title":"<code>conjuring.spells.docker</code>","text":"<p>Docker: remove containers and volumes.</p>"},{"location":"spells/#conjuring.spells.docker.rm_containers","title":"<code>rm_containers(c, container='', all_=False, exited=False)</code>","text":"<p>Remove Docker containers.</p> Source code in <code>src/conjuring/spells/docker.py</code> <pre><code>@task(\nhelp={\n\"container\": \"Container name to remove (regexp)\",\n\"all_\": \"All containers\",\n\"exited\": \"Exited containers\",\n},\n)\ndef rm_containers(c: Context, container: str = \"\", all_: bool = False, exited: bool = False) -&gt; None:\n\"\"\"Remove Docker containers.\"\"\"\ncmd = []\nif all_:\ncmd = [\"docker ps -a\"]\nelif exited:\ncmd = [\"docker ps -a -f status=exited\"]\nelif container:\ncmd = [\"docker ps -a | grep -e\", container]\nif not cmd:\nprint_error(\"Choose one argument. Run with --help to see available argument\")\nreturn\nrun_command(c, *cmd, dry=False)\nrun_command(c, *cmd, \"| tail +2 | awk '{print $1}' | xargs docker rm -f\")\nrun_command(c, *cmd)\n</code></pre>"},{"location":"spells/#conjuring.spells.docker.rm_volumes","title":"<code>rm_volumes(c, dangling=False)</code>","text":"<p>Remove Docker volumes.</p> Source code in <code>src/conjuring/spells/docker.py</code> <pre><code>@task(help=({\"dangling\": \"Dangling volumes\"}))\ndef rm_volumes(c: Context, dangling: bool = False) -&gt; None:\n\"\"\"Remove Docker volumes.\"\"\"\ncmd = \"\"\nif dangling:\ncmd = 'docker volume ls -f \"dangling=true\"'\nif not cmd:\nprint_error(\"Choose one argument. Run with --help to see available argument\")\nreturn\nrun_command(c, cmd, dry=False)\nrun_command(c, f\"docker volume rm $({cmd} -q)\")\nrun_command(c, cmd)\n</code></pre>"},{"location":"spells/#conjuring.spells.duplicity","title":"<code>conjuring.spells.duplicity</code>","text":"<p>Backup and restore with Duplicity.</p>"},{"location":"spells/#conjuring.spells.duplicity.backup","title":"<code>backup(c)</code>","text":"<p>Backup files with Duplicity.</p> Source code in <code>src/conjuring/spells/duplicity.py</code> <pre><code>@task\ndef backup(c: Context) -&gt; None:\n\"\"\"Backup files with Duplicity.\"\"\"\nhost = print_hostname(c)\nbackup_dir = f\"file://{BACKUP_DIR}/{host}/duplicity/\"\n# To back up directly on OneDrive:\n# backup_dir = f\"onedrive://Backup/{host}/duplicity/\"\ntyper.echo(f\"Backup dir: {backup_dir}\")\ntemplate_file = Path(\"~/dotfiles/duplicity-template.cfg\").expanduser()\ntyper.echo(f\"Template file: {template_file}\")\ntemplate_contents = template_file.read_text()\nduplicity_config = Template(template_contents).substitute({\"HOME\": Path.home()})\nwith NamedTemporaryFile(\"r+\", delete=False) as temp_file:\ntemp_file.write(duplicity_config)\ntemp_file.flush()\nrun_command(\nc,\n\"duplicity\",\nf\"--name='{host}-backup'\",\n\"-v info\",\nf\"--include-filelist={temp_file.name}\",\n\"--exclude='**' $HOME/\",\nbackup_dir,\n)\n</code></pre>"},{"location":"spells/#conjuring.spells.duplicity.print_hostname","title":"<code>print_hostname(c)</code>","text":"<p>Print the hostname of the current machine.</p> Source code in <code>src/conjuring/spells/duplicity.py</code> <pre><code>def print_hostname(c: Context) -&gt; str:\n\"\"\"Print the hostname of the current machine.\"\"\"\nhost = c.run(\"hostname | sed 's/.local//'\").stdout.strip()\ntyper.echo(f\"Host: {host}\")\nreturn host\n</code></pre>"},{"location":"spells/#conjuring.spells.duplicity.restore","title":"<code>restore(c)</code>","text":"<p>Restore files with Duplicity. You will be prompted to choose the source dir. Restore dir is ~/Downloads.</p> Source code in <code>src/conjuring/spells/duplicity.py</code> <pre><code>@task\ndef restore(c: Context) -&gt; None:\n\"\"\"Restore files with Duplicity. You will be prompted to choose the source dir. Restore dir is ~/Downloads.\"\"\"\nprint_hostname(c)\nchosen_dir = run_with_fzf(c, f\"fd -d 2 -t d duplicity {BACKUP_DIR}\")\nif not chosen_dir:\nreturn\nsource_computer = Path(chosen_dir).parent.name\nc.run(f\"duplicity restore file://{chosen_dir} ~/Downloads/duplicity-restore/{source_computer}/\")\n</code></pre>"},{"location":"spells/#conjuring.spells.fork","title":"<code>conjuring.spells.fork</code>","text":"<p>GitHub forks: configure remote and sync.</p>"},{"location":"spells/#conjuring.spells.fork.remote","title":"<code>remote(c, username, remote='')</code>","text":"<p>Configure a remote for a fork.</p> Source code in <code>src/conjuring/spells/fork.py</code> <pre><code>@task\ndef remote(c: Context, username: str, remote: str = \"\") -&gt; None:\n\"\"\"[Configure a remote for a fork](https://docs.github.com/en/github/collaborating-with-issues-and-pull-requests/configuring-a-remote-for-a-fork).\"\"\"\nif username.startswith(\"-\"):\nmsg = \"Arguments should be: username [--remote]\"\nraise Exit(msg)\nif not remote:\nremote = username\nproject = c.run(r\"git remote -v | rg origin | head -1 | rg -o '/(.+)\\.git' -r '$1'\", pty=False).stdout.strip()\nc.run(f\"git remote add {remote} https://github.com/{username}/{project}.git\", warn=True)\nc.run(\"git remote -v\")\n</code></pre>"},{"location":"spells/#conjuring.spells.fork.sync","title":"<code>sync(c, remote='upstream')</code>","text":"<p>Sync a fork.</p> Source code in <code>src/conjuring/spells/fork.py</code> <pre><code>@task\ndef sync(c: Context, remote: str = \"upstream\") -&gt; None:\n\"\"\"[Sync a fork](https://docs.github.com/en/github/collaborating-with-issues-and-pull-requests/syncing-a-fork).\"\"\"\nc.run(f\"git fetch {remote}\")\nexisting_branch = Git(c).checkout(\"master\", \"main\")\nc.run(f\"git merge {remote}/{existing_branch}\")\nc.run(\"git push\")\n</code></pre>"},{"location":"spells/#conjuring.spells.generic","title":"<code>conjuring.spells.generic</code>","text":"<p>Generic spells: list to-do items in files.</p>"},{"location":"spells/#conjuring.spells.generic.Location","title":"<code>Location</code>  <code>dataclass</code>","text":"<p>Location of a to-do item in a file.</p> Source code in <code>src/conjuring/spells/generic.py</code> <pre><code>@dataclass\nclass Location:\n\"\"\"Location of a to-do item in a file.\"\"\"\nfile: str\nline: int\ncomment: str\ndef __post_init__(self) -&gt; None:\nself.line = int(self.line)\nself.comment = self.comment.strip()\n</code></pre>"},{"location":"spells/#conjuring.spells.generic.ToDoItem","title":"<code>ToDoItem</code>  <code>dataclass</code>","text":"<p>A to-do item.</p> Source code in <code>src/conjuring/spells/generic.py</code> <pre><code>@dataclass(frozen=True)\nclass ToDoItem:\n\"\"\"A to-do item.\"\"\"\nwhich: str\ndescription: str\n@property\ndef sort_key(self) -&gt; str:\n\"\"\"Key to sort the instance.\n        String concatenation works.\n        Checking both fields separately with ``and`` conditions didn't work: sort order was not as expected\n        (meaning fix-me tasks first, then to-do tasks).\n        \"\"\"\nreturn f\"{self.which}-{self.description.lower()}\"\ndef __lt__(self, other: ToDoItem) -&gt; bool:\nreturn self.sort_key &lt; other.sort_key\n</code></pre>"},{"location":"spells/#conjuring.spells.generic.ToDoItem.sort_key","title":"<code>sort_key: str</code>  <code>property</code>","text":"<p>Key to sort the instance.</p> <p>String concatenation works. Checking both fields separately with <code>and</code> conditions didn't work: sort order was not as expected (meaning fix-me tasks first, then to-do tasks).</p>"},{"location":"spells/#conjuring.spells.generic.todo","title":"<code>todo(c, cz=False, valid=True, invalid=True, short=False, priority=False)</code>","text":"<p>List to-dos and fix-mes in code. Optionally check if the description follows Conventional Commits (cz check).</p> Source code in <code>src/conjuring/spells/generic.py</code> <pre><code>@task(\nhelp={\n\"cz\": \"Run commitizen (cz check) to validate the description of the to-do item as a commit message\",\n\"valid\": \"When using cz check, print valid to-do items\",\n\"invalid\": \"When using cz check, print invalid to-do items\",\n\"short\": \"Short format: only the description, without the lines of code where to-do items were found\",\n\"priority\": f\"Show only higher priority tasks ({FIX_ME})\",\n},\n)\ndef todo(  # noqa: PLR0913\nc: Context,\ncz: bool = False,\nvalid: bool = True,\ninvalid: bool = True,\nshort: bool = False,\npriority: bool = False,\n) -&gt; None:\n\"\"\"List to-dos and fix-mes in code. Optionally check if the description follows Conventional Commits (cz check).\"\"\"\nall_todos: dict[ToDoItem, list[Location]] = defaultdict(list)\nall_keys: list[ToDoItem] = []\nfor which in (FIX_ME,) if priority else (FIX_ME, TO_DO):\n# This command freezes if pty=False\nfor line in run_lines(c, f\"rg --color=never --no-heading {which}\", warn=True, pty=True):\nbefore, after = line.split(which, maxsplit=1)  # type: str,str\nkey = ToDoItem(which, after.strip(\": \"))\nall_keys.append(key)\nlocation = Location(*before.strip(\"/# \").split(\":\", maxsplit=2))  # type: ignore[arg-type]\nall_todos[key].append(location)\nfor item, locations in sorted(all_todos.items()):  # type: ToDoItem, list[Location]\nfunc = print_success\nif cz:\nresult = run_command(c, \"cz check -m\", quote(item.description), hide=True, warn=True)\nif result.ok:\nif not valid:\ncontinue\nelse:\nif not invalid:\ncontinue\nfunc = print_error\nfunc(f\"{item.which}: {item.description}\")\nif short:\ncontinue\nfor loc in locations:  # type: Location\ntyper.echo(f\"   {loc.file}:{loc.line} {loc.comment}\")\n</code></pre>"},{"location":"spells/#conjuring.spells.git","title":"<code>conjuring.spells.git</code>","text":"<p>Git: update all, extract subtree, rewrite history, ...</p>"},{"location":"spells/#conjuring.spells.git.Git","title":"<code>Git</code>","text":"<p>Git helpers.</p> Source code in <code>src/conjuring/spells/git.py</code> <pre><code>class Git:\n\"\"\"Git helpers.\"\"\"\n# Use \"tail +2\" to remove the blank line at the top\nSHOW_ALL_FILE_HISTORY = 'git log --pretty=\"format:\" --name-only | sort -u | tail +2'\ndef __init__(self, context: Context) -&gt; None:\nself.context = context\ndef current_branch(self) -&gt; str:\n\"\"\"Return the current branch name.\"\"\"\nreturn run_stdout(self.context, \"git branch --show-current\")\ndef default_branch(self) -&gt; str:\n\"\"\"Return the default branch name (master/main/develop/development).\"\"\"\nreturn run_stdout(\nself.context,\n\"git branch -a | rg -o -e /master -e /develop.+ -e /main | sort -u | cut -b 2- | head -1\",\n)\ndef checkout(self, *branches: str) -&gt; str:\n\"\"\"Try checking out the specified branches in order.\"\"\"\nfor branch in branches:\ntry:\nself.context.run(f\"git checkout {branch}\")\nexcept UnexpectedExit:\npass\nelse:\nreturn branch\nreturn \"\"\n@property\ndef github_username(self) -&gt; str:\n\"\"\"The GitHub username configured in the global settings.\"\"\"\nreturn global_config()[\"github\"][\"user\"]\ndef choose_local_branch(self, branch: str) -&gt; str:\n\"\"\"Choose a local branch.\"\"\"\nreturn run_with_fzf(self.context, \"git branch --list | rg -v develop | cut -b 3-\", query=branch)\n</code></pre>"},{"location":"spells/#conjuring.spells.git.Git.github_username","title":"<code>github_username: str</code>  <code>property</code>","text":"<p>The GitHub username configured in the global settings.</p>"},{"location":"spells/#conjuring.spells.git.Git.checkout","title":"<code>checkout(*branches)</code>","text":"<p>Try checking out the specified branches in order.</p> Source code in <code>src/conjuring/spells/git.py</code> <pre><code>def checkout(self, *branches: str) -&gt; str:\n\"\"\"Try checking out the specified branches in order.\"\"\"\nfor branch in branches:\ntry:\nself.context.run(f\"git checkout {branch}\")\nexcept UnexpectedExit:\npass\nelse:\nreturn branch\nreturn \"\"\n</code></pre>"},{"location":"spells/#conjuring.spells.git.Git.choose_local_branch","title":"<code>choose_local_branch(branch)</code>","text":"<p>Choose a local branch.</p> Source code in <code>src/conjuring/spells/git.py</code> <pre><code>def choose_local_branch(self, branch: str) -&gt; str:\n\"\"\"Choose a local branch.\"\"\"\nreturn run_with_fzf(self.context, \"git branch --list | rg -v develop | cut -b 3-\", query=branch)\n</code></pre>"},{"location":"spells/#conjuring.spells.git.Git.current_branch","title":"<code>current_branch()</code>","text":"<p>Return the current branch name.</p> Source code in <code>src/conjuring/spells/git.py</code> <pre><code>def current_branch(self) -&gt; str:\n\"\"\"Return the current branch name.\"\"\"\nreturn run_stdout(self.context, \"git branch --show-current\")\n</code></pre>"},{"location":"spells/#conjuring.spells.git.Git.default_branch","title":"<code>default_branch()</code>","text":"<p>Return the default branch name (master/main/develop/development).</p> Source code in <code>src/conjuring/spells/git.py</code> <pre><code>def default_branch(self) -&gt; str:\n\"\"\"Return the default branch name (master/main/develop/development).\"\"\"\nreturn run_stdout(\nself.context,\n\"git branch -a | rg -o -e /master -e /develop.+ -e /main | sort -u | cut -b 2- | head -1\",\n)\n</code></pre>"},{"location":"spells/#conjuring.spells.git.PrefixBranch","title":"<code>PrefixBranch</code>  <code>dataclass</code>","text":"<p>Tuple of prefix and branch name.</p> Source code in <code>src/conjuring/spells/git.py</code> <pre><code>@dataclass(frozen=True)\nclass PrefixBranch:\n\"\"\"Tuple of prefix and branch name.\"\"\"\nprefix: str\nbranch: str\n</code></pre>"},{"location":"spells/#conjuring.spells.git.body","title":"<code>body(c, prefix=False, original_order=False)</code>","text":"<p>Prepare a commit body to be used on pull requests and squashed commits.</p> Source code in <code>src/conjuring/spells/git.py</code> <pre><code>@task(\nhelp={\n\"prefix\": \"Keep the Conventional Commits prefix\",\n\"original_order\": \"Don't sort bullets, keep them in original order\",\n},\n)\ndef body(c: Context, prefix: bool = False, original_order: bool = False) -&gt; None:\n\"\"\"Prepare a commit body to be used on pull requests and squashed commits.\"\"\"\ndefault_branch = set_default_branch(c)\nbullets = []\nfor line in run_lines(c, f\"git log {default_branch}..\", \"--format=%s%n%b\"):\nclean = line.strip(\" -\")\nif (\n\"Merge branch\" in clean\nor \"Merge remote-tracking branch\" in clean\nor \"Revert \" in clean\nor \"This reverts\" in clean\nor not clean\n):\ncontinue\n# Remove Jira ticket with regex\nclean = REGEX_JIRA.sub(\"\", clean).replace(\"()\", \"\").replace(\"[]\", \"\").strip(\" -\")\n# Split on the Conventional Commit prefix\nif not prefix and \":\" in clean:\nclean = clean.split(\":\", 1)[1].strip()\nbullets.append(f\"- {clean}\")\nresults = bullets if original_order else sorted(set(bullets))\ntyper.echo(\"\\n\".join(results))\n</code></pre>"},{"location":"spells/#conjuring.spells.git.changes_since_tag","title":"<code>changes_since_tag(c, tag='', files=False, verbose=False)</code>","text":"<p>Display changes (commits or files) since the last tag (or a chosen tag).</p> Source code in <code>src/conjuring/spells/git.py</code> <pre><code>@task(\nhelp={\n\"tag\": \"Name of the tag to compare to (default: last created tag)\",\n\"files\": \"Display files instead of commits (default: false)\",\n\"verbose\": \"Files: display changes/insertions/deletion.\"\n\" Commits: display the full commit message, author... (default: False)\",\n},\n)\ndef changes_since_tag(c: Context, tag: str = \"\", files: bool = False, verbose: bool = False) -&gt; None:\n\"\"\"Display changes (commits or files) since the last tag (or a chosen tag).\"\"\"\nwhich_tag = tag or run_stdout(c, \"git tag --list --sort -creatordate | head -1\", hide=False, dry=False)\ndefault_branch = set_default_branch(c)\nif files:\noption = \"\" if verbose else \" --name-only\"\nc.run(f\"git diff --stat {which_tag} origin/{default_branch}{option}\")\nelse:\noption = \"\" if verbose else \" --oneline\"\nc.run(f\"git log {which_tag}..origin/{default_branch}{option}\")\n</code></pre>"},{"location":"spells/#conjuring.spells.git.extract_subtree","title":"<code>extract_subtree(c, new_project_dir, reset=False, keep=False)</code>","text":"<p>Extract files from subdirectories of the current Git repo to another repo, using git subtree.</p> <p>The files will be moved to the root of the new repo.</p> <p>Solutions adapted from: - https://serebrov.github.io/html/2021-09-13-git-move-history-to-another-repository.html - https://stackoverflow.com/questions/25574407/git-subtree-split-two-directories/58253979#58253979</p> Source code in <code>src/conjuring/spells/git.py</code> <pre><code>@task(\nhelp={\n\"new_project_dir\": \"Dir of the project to be created. The dir might exist or not\",\n\"reset\": \"Remove the new dir and start over\",\n\"keep\": \"Keep branches and remote after the extracting is done\",\n},\n)\ndef extract_subtree(c: Context, new_project_dir: str, reset: bool = False, keep: bool = False) -&gt; None:\n\"\"\"Extract files from subdirectories of the current Git repo to another repo, using git subtree.\n    The files will be moved to the root of the new repo.\n    Solutions adapted from:\n    - https://serebrov.github.io/html/2021-09-13-git-move-history-to-another-repository.html\n    - https://stackoverflow.com/questions/25574407/git-subtree-split-two-directories/58253979#58253979\n    \"\"\"\nnew_project_path: Path = Path(new_project_dir).expanduser().absolute()\nif reset:\nc.run(f\"rm -rf {new_project_path}\")\nnew_project_path.mkdir(parents=False, exist_ok=True)\nold_project_path = Path.cwd()\nall_files = set(run_lines(c, Git.SHOW_ALL_FILE_HISTORY, dry=False))\nchosen_files = set(\nrun_with_fzf(\nc,\nGit.SHOW_ALL_FILE_HISTORY,\ndry=False,\nheader=\"Use TAB to choose the files you want to KEEP\",\nmulti=True,\npreview=\"test -f {} &amp;&amp; head -20 {} || echo FILE NOT FOUND, IT EXISTS ONLY IN GIT HISTORY\",\n),\n)\nsub_dirs = {part.rsplit(\"/\", 1)[0] for part in chosen_files}\nobliterate = set(all_files.difference(chosen_files))\nfirst_date = run_stdout(c, 'git log --format=\"%cI\" --root | sort -u | head -1')\nprefixes: list[str] = []\nfor sub_dir in sorted(sub_dirs):\nabsolute_subdir = Path(sub_dir).expanduser().absolute()\n# Add slash to the end\nprefixes.append(str(absolute_subdir.relative_to(Path.cwd())).rstrip(\"/\") + \"/\")\nwith c.cd(new_project_dir):\nrun_multiple(\nc,\n\"git init\",\n\"touch README.md\",\n\"git add README.md\",\nf'git commit -m \"chore: first commit\" --date {first_date}',\nf\"git remote add -f upstream {old_project_path}\",\n\"git checkout -b upstream_master upstream/master\",\npty=False,\n)\npairs: set[PrefixBranch] = set()\nfor prefix in prefixes:\nif not Path(prefix).exists():\nprint_error(f\"Skipping non-existent prefix {prefix}...\")\ncontinue\nclean = prefix.strip(\" /\").replace(\"/\", \"_\")\nbranch = f\"upstream_subtree_{clean}\"\nlocal_obliterate = {f[len(prefix) :] for f in obliterate if f.startswith(prefix)}\npairs.add(PrefixBranch(prefix, branch))\nrun_multiple(\nc,\n\"git checkout upstream_master\",\nf\"git subtree split --prefix={prefix} -b {branch}\",\nf\"git checkout {branch}\",\n\"git obliterate \" + \" \".join(sorted(local_obliterate)) if obliterate else \"\",\n\"git checkout master\",\n# TODO: fix: deal with files that have the same name in different subdirs\n#  The files are merged in the root, without prefix.\n#  What happens if a file has the same name in multiple subdirs? e.g.: bin/file.py and src/file.py\nf\"git merge {branch} --allow-unrelated-histories -m 'refactor: merge subtree {prefix}'\",\n)\nif obliterate:\nc.run(\"git obliterate \" + \" \".join(sorted(obliterate)))\nif not keep:\nrun_multiple(\nc,\n\"git branch -D upstream_master\",\n*[f\"git branch -D {pair.branch}\" for pair in pairs],\n\"git remote remove upstream\",\n)\nhistory(c, full=True)\nprint_error(\"Don't forget to switch to the new repo:\", f\"  cd {new_project_dir}\", nl=True)\nprint_success(\n\"Next steps:\",\n\"- Run 'git obliterate' manually for files in Git history (listed above) you still want to remove\",\n\"- Run 'invoke git.rewrite' to fix dates and authors\",\n\"- Create a new empty repo on https://github.com/new without initializing it (no README/.gitignore/license)\",\n\"- Follow the instructions to add a remote (from 'push an existing repository from the command line')\",\n\"- Push files to the new repo with:\",\n\"  git push -u origin master\",\nnl=True,\n)\n</code></pre>"},{"location":"spells/#conjuring.spells.git.global_config","title":"<code>global_config()</code>  <code>cached</code>","text":"<p>Global Git configuration.</p> Source code in <code>src/conjuring/spells/git.py</code> <pre><code>@lru_cache\ndef global_config() -&gt; ConfigParser:\n\"\"\"Global Git configuration.\"\"\"\nconfig = ConfigParser()\nconfig.read(GLOBAL_GITCONFIG_PATH)\nreturn config\n</code></pre>"},{"location":"spells/#conjuring.spells.git.history","title":"<code>history(c, full=False, files=False, author=False, dates=False)</code>","text":"<p>Grep the whole Git log and display information.</p> Source code in <code>src/conjuring/spells/git.py</code> <pre><code>@task(\nhelp={\n\"full\": \"Display all info: files, authors, dates\",\n\"files\": \"Display all files in Git history, even the ones that were deleted and don't exist anymore\",\n\"author\": \"Display authors\",\n\"dates\": \"Display committer and author dates in different colors\",\n},\n)\ndef history(c: Context, full: bool = False, files: bool = False, author: bool = False, dates: bool = False) -&gt; None:\n\"\"\"Grep the whole Git log and display information.\"\"\"\noption_chosen = False\nif full:\noption_chosen = True\nfiles = author = dates = True\nif files:\noption_chosen = True\nc.run(Git.SHOW_ALL_FILE_HISTORY)\nif author:\noption_chosen = True\nc.run(\"git log --name-only | rg author | sort -u\")\nif dates:\noption_chosen = True\nheader = True\nfor line in run_lines(c, 'git log --format=\"%H|%cI|%aI|%GK|%s\"', hide=False):\nif header:\nprint_success(\"Green = dates are equal\")\nprint_error(\"Red = dates are different\")\ntyper.echo(\n\"Commit                                   Committer Date            \"\n\"Author Date               GPG key          Subject\",\n)\nheader = False\nfields = line.split(\"|\")\ncommitter_date = fields[1]\nauthor_date = fields[2]\nfunc = print_success if committer_date == author_date else print_error\nfunc(*fields)\nif not option_chosen:\nmsg = \"Choose at least one option: --full, --files, --author, --dates\"\nraise Exit(msg, 1)\n</code></pre>"},{"location":"spells/#conjuring.spells.git.merge_default","title":"<code>merge_default(c, remote=False, update=True, push=True, rebase=False)</code>","text":"<p>Merge the default branch of the repo. Also set it with \"git config\", if not already set.</p> Source code in <code>src/conjuring/spells/git.py</code> <pre><code>@task(\nhelp={\n\"remote\": \"List remote branches (default: False)\",\n\"update\": \"Update the repo before merging (default: True)\",\n\"push\": \"Push the merge to the remote (default: True)\",\n\"rebase\": \"Rebase the default branch before merging (default: False)\",\n},\n)\ndef merge_default(\nc: Context,\nremote: bool = False,\nupdate: bool = True,\npush: bool = True,\nrebase: bool = False,\n) -&gt; None:\n\"\"\"Merge the default branch of the repo. Also set it with \"git config\", if not already set.\"\"\"\ndefault_branch = set_default_branch(c, remote)\nif update:\ntidy_up(c)\nwhich_verb = \"rebase\" if rebase else \"merge\"\nrun_command(c, f\"git {which_verb}\", f\"origin/{default_branch}\")\nif push:\nforce_option = \"--force-with-lease\" if rebase else \"\"\nrun_command(c, \"git push\", force_option)\n</code></pre>"},{"location":"spells/#conjuring.spells.git.rewrite","title":"<code>rewrite(c, commit='--root', gpg=True, author=True)</code>","text":"<p>Rewrite a range of commits, signing with GPG and setting the author.</p> <p>https://git-scm.com/docs/git-commit https://git-scm.com/docs/git-rebase</p> Source code in <code>src/conjuring/spells/git.py</code> <pre><code>@task(\nhelp={\n\"commit\": \"Base commit to be used for the range (default: --root)\",\n\"gpg\": \"Sign the commit (default: True)\",\n\"author\": \"Set the current author (from 'git config') on the commit range\",\n},\n)\ndef rewrite(c: Context, commit: str = \"--root\", gpg: bool = True, author: bool = True) -&gt; None:\n\"\"\"Rewrite a range of commits, signing with GPG and setting the author.\n    https://git-scm.com/docs/git-commit\n    https://git-scm.com/docs/git-rebase\n    \"\"\"\ngpg_flag = \" --gpg-sign\" if gpg else \" --no-gpg-sign\"\nauthor_flag = \"\"\nif author:\nname = run_stdout(c, \"git config user.name\", dry=False)\nemail = run_stdout(c, \"git config user.email\", dry=False)\nauthor_flag = f' --author \"{name} &lt;{email}&gt;\"'\nc.run(f'git log --format=\"%H %cI %aI %s\" {commit} &gt; $TMPDIR/rebase_sign_hashlist')\nc.run(\n\"git rebase --committer-date-is-author-date --exec 'GIT_COMMITTER_DATE=\"\n'$(fgrep -m 1 \"$(git log -1 --format=\"%aI %s\" $GIT_COMMIT)\" $TMPDIR/rebase_sign_hashlist'\nf' | cut -d\" \" -f3) git commit --amend --no-edit -n{author_flag}{gpg_flag}\\' -i {commit}',\n)\nhistory(c, dates=True)\ntyper.echo()\ntyper.echo(\"NOTE: If commits were modified during the rebase above, their committer date will be the current date\")\ntyper.echo(\"Rebase again with this command, without changing any commit, and all dates should be green\")\n</code></pre>"},{"location":"spells/#conjuring.spells.git.set_default_branch","title":"<code>set_default_branch(c, remote=False)</code>","text":"<p>Set the default branch config on the repo, if not configured yet.</p> Source code in <code>src/conjuring/spells/git.py</code> <pre><code>def set_default_branch(c: Context, remote: bool = False) -&gt; str:\n\"\"\"Set the default branch config on the repo, if not configured yet.\"\"\"\ncmd_read_default_branch = \"git config git-extras.default-branch\"\ndefault_branch = run_stdout(c, cmd_read_default_branch, warn=True, dry=False)\nif not default_branch:\ndefault_branch = run_with_fzf(\nc,\n\"git branch --list\",\n\"--all\" if remote else \"\",\n\"| cut -b 3- | grep -v HEAD | sed -E 's#remotes/[^/]+/##g' | sort -u\",\n)\nrun_command(c, cmd_read_default_branch, default_branch)\nrun_command(c, \"git config init.defaultBranch\", default_branch)\nrun_command(c, \"git config --list | rg default.*branch\")\nreturn default_branch\n</code></pre>"},{"location":"spells/#conjuring.spells.git.switch_url_to","title":"<code>switch_url_to(c, remote='origin', https=False)</code>","text":"<p>Set an SSH or HTTPS URL for a remote.</p> Source code in <code>src/conjuring/spells/git.py</code> <pre><code>@task\ndef switch_url_to(c: Context, remote: str = \"origin\", https: bool = False) -&gt; None:\n\"\"\"Set an SSH or HTTPS URL for a remote.\"\"\"\nregex = r\"'git@(.+\\.com):(.+/.+)\\.git\\s'\" if https else r\"'/([^/]+\\.com)/([^/]+/.+)\\s\\('\"\nreplace = \"'$1/$2'\" if https else \"'$1:$2'\"\nresult = c.run(f\"git remote -v | rg {remote} | head -1 | rg -o {regex} -r {replace}\", warn=True, pty=False)\nmatch = result.stdout.strip()\nif not match:\ntyper.echo(f\"{COLOR_LIGHT_RED}Match not found{COLOR_NONE}\")\nelse:\nrepo = f\"https://{match}\" if https else f\"git@{match}\"\nif not repo.endswith(\".git\"):\nrepo += \".git\"\nc.run(f\"git remote set-url {remote} {repo}\")\nc.run(\"git remote -v\")\n</code></pre>"},{"location":"spells/#conjuring.spells.git.tidy_up","title":"<code>tidy_up(c)</code>","text":"<p>Prune remotes, update all branches of the repo, delete merged/squashed branches.</p> Source code in <code>src/conjuring/spells/git.py</code> <pre><code>@task\ndef tidy_up(c: Context) -&gt; None:\n\"\"\"Prune remotes, update all branches of the repo, delete merged/squashed branches.\"\"\"\nc.run(\"gitup .\")\nc.run(\"git delete-merged-branches\")\n# warn=True is needed; apparently, this command fails when there is no branch, and execution is stopped\nc.run(\"git delete-squashed-branches\", warn=True)\nfor remote in run_lines(c, \"git remote\", dry=False):\nc.run(f\"git remote prune {remote}\")\n</code></pre>"},{"location":"spells/#conjuring.spells.git.update_all","title":"<code>update_all(c, group='')</code>","text":"<p>Run gita super to update and clean branches.</p> Source code in <code>src/conjuring/spells/git.py</code> <pre><code>@task(klass=MagicTask)\ndef update_all(c: Context, group: str = \"\") -&gt; None:\n\"\"\"Run gita super to update and clean branches.\"\"\"\nparts = [\"gita\", \"super\"]\nif group:\nparts.append(group)\ngita_super = \" \".join(parts)\nc.run(f\"{gita_super} up &amp;&amp; {gita_super} delete-merged-branches\")\n</code></pre>"},{"location":"spells/#conjuring.spells.git.watch","title":"<code>watch(c)</code>","text":"<p>Watch a build on GitHub Actions, then open a pull request or repo after the build is over.</p> Source code in <code>src/conjuring/spells/git.py</code> <pre><code>@task()\ndef watch(c: Context) -&gt; None:\n\"\"\"Watch a build on GitHub Actions, then open a pull request or repo after the build is over.\"\"\"\ncurrent_branch = Git(c).current_branch()\nprint_success(f\"Current branch = {current_branch}\")\nc.run(\"gh run watch\", warn=True)\nout = c.run(f\"gh pr view {current_branch} --web\", warn=True).stdout.strip()\nif \"no pull requests found for branch\" in out:\nc.run(\"gh repo view --web\")\n</code></pre>"},{"location":"spells/#conjuring.spells.jrnl","title":"<code>conjuring.spells.jrnl</code>","text":"<p>Query tags and entries with the jrnl note-taking tool.</p>"},{"location":"spells/#conjuring.spells.jrnl.edit_last","title":"<code>edit_last(c, journal='')</code>","text":"<p>Edit the last jrnl entry.</p> Source code in <code>src/conjuring/spells/jrnl.py</code> <pre><code>@task\ndef edit_last(c: Context, journal: str = \"\") -&gt; None:\n\"\"\"Edit the last jrnl entry.\"\"\"\ncmd = [\"jrnl\"]\nif journal:\ncmd.append(journal)\ncmd.append(\"-1 --edit\")\nc.run(\" \".join(cmd))\n</code></pre>"},{"location":"spells/#conjuring.spells.jrnl.query","title":"<code>query(c, n=0, contains='', edit=False, fancy=False, short=False, journal='')</code>","text":"<p>Query jrnl entries.</p> Source code in <code>src/conjuring/spells/jrnl.py</code> <pre><code>@task\ndef query(  # noqa: PLR0913\nc: Context,\nn: int = 0,\ncontains: str = \"\",\nedit: bool = False,\nfancy: bool = False,\nshort: bool = False,\njournal: str = \"\",\n) -&gt; None:\n\"\"\"Query jrnl entries.\"\"\"\nformat_ = \"pretty\"\nif fancy:\nformat_ = \"fancy\"\nelif short:\nformat_ = \"short\"\ncmd = [\"jrnl\"]\nif journal:\ncmd.append(journal)\nif n:\ncmd.append(f\"-n {n}\")\ncmd.append(f\"--format {format_}\")\nif contains:\ncmd.append(f\"-contains {contains}\")\nif edit:\ncmd.append(\"--edit\")\nc.run(\" \".join(cmd))\n</code></pre>"},{"location":"spells/#conjuring.spells.jrnl.tags","title":"<code>tags(c, sort=False, rg='', journal='')</code>","text":"<p>Query jrnl tags.</p> Source code in <code>src/conjuring/spells/jrnl.py</code> <pre><code>@task\ndef tags(c: Context, sort: bool = False, rg: str = \"\", journal: str = \"\") -&gt; None:\n\"\"\"Query jrnl tags.\"\"\"\ncmd = [\"jrnl\"]\nif journal:\ncmd.append(journal)\ncmd.append(\"--tags\")\nif sort:\ncmd.append(\"| sort -u\")\nif rg:\ncmd.append(f\"| rg {rg}\")\nc.run(\" \".join(cmd))\n</code></pre>"},{"location":"spells/#conjuring.spells.k8s","title":"<code>conjuring.spells.k8s</code>","text":"<p>Kubernetes: get pods, show variables from config maps, validate score and more.</p>"},{"location":"spells/#conjuring.spells.k8s.Kubectl","title":"<code>Kubectl</code>  <code>dataclass</code>","text":"<p>Kubectl commands.</p> Source code in <code>src/conjuring/spells/k8s.py</code> <pre><code>@dataclass\nclass Kubectl:\n\"\"\"Kubectl commands.\"\"\"\ncontext: Context\ndef choose_apps(self, partial_app_name: Optional[str] = None, *, multi: bool = False) -&gt; list[str]:\n\"\"\"Select apps from Kubernetes deployments, using a partial app name and fzf.\"\"\"\nreturn cast(\nlist[str],\nrun_with_fzf(\nself.context,\n\"\"\"kubectl get deployments.apps -o jsonpath='{range .items[*]}{.metadata.name}{\"\\\\n\"}{end}'\"\"\",\nquery=partial_app_name or \"\",\nmulti=multi,\n),\n)\n@staticmethod\ndef _app_selector(apps: list[str]) -&gt; str:\n\"\"\"Return the app selector for one or more apps.\"\"\"\nsorted_unique_apps = sorted(set(apps))\nif len(sorted_unique_apps) == 1:\nreturn f\"-l app={sorted_unique_apps[0]}\"\nselector = f\" in ({', '.join(sorted_unique_apps)})\"\nreturn f\"-l 'app{selector}'\"\ndef cmd_get(self, resource: str, apps: list[str]) -&gt; str:\n\"\"\"Return the kubectl get command for one or more apps.\"\"\"\nreturn f\"kubectl get {resource} {self._app_selector(apps)}\"\ndef run_get(self, resource: str, apps: list[str]) -&gt; Result:\n\"\"\"Run the kubectl get command for one or more apps.\"\"\"\nreturn run_command(self.context, self.cmd_get(resource, apps))\n</code></pre>"},{"location":"spells/#conjuring.spells.k8s.Kubectl.choose_apps","title":"<code>choose_apps(partial_app_name=None, *, multi=False)</code>","text":"<p>Select apps from Kubernetes deployments, using a partial app name and fzf.</p> Source code in <code>src/conjuring/spells/k8s.py</code> <pre><code>def choose_apps(self, partial_app_name: Optional[str] = None, *, multi: bool = False) -&gt; list[str]:\n\"\"\"Select apps from Kubernetes deployments, using a partial app name and fzf.\"\"\"\nreturn cast(\nlist[str],\nrun_with_fzf(\nself.context,\n\"\"\"kubectl get deployments.apps -o jsonpath='{range .items[*]}{.metadata.name}{\"\\\\n\"}{end}'\"\"\",\nquery=partial_app_name or \"\",\nmulti=multi,\n),\n)\n</code></pre>"},{"location":"spells/#conjuring.spells.k8s.Kubectl.cmd_get","title":"<code>cmd_get(resource, apps)</code>","text":"<p>Return the kubectl get command for one or more apps.</p> Source code in <code>src/conjuring/spells/k8s.py</code> <pre><code>def cmd_get(self, resource: str, apps: list[str]) -&gt; str:\n\"\"\"Return the kubectl get command for one or more apps.\"\"\"\nreturn f\"kubectl get {resource} {self._app_selector(apps)}\"\n</code></pre>"},{"location":"spells/#conjuring.spells.k8s.Kubectl.run_get","title":"<code>run_get(resource, apps)</code>","text":"<p>Run the kubectl get command for one or more apps.</p> Source code in <code>src/conjuring/spells/k8s.py</code> <pre><code>def run_get(self, resource: str, apps: list[str]) -&gt; Result:\n\"\"\"Run the kubectl get command for one or more apps.\"\"\"\nreturn run_command(self.context, self.cmd_get(resource, apps))\n</code></pre>"},{"location":"spells/#conjuring.spells.k8s.config_map","title":"<code>config_map(c, app, rg='')</code>","text":"<p>Show the config map for an app.</p> Source code in <code>src/conjuring/spells/k8s.py</code> <pre><code>@task(help={\"rg\": \"Filter results with rg\"})\ndef config_map(c: Context, app: str, rg: str = \"\") -&gt; None:\n\"\"\"Show the config map for an app.\"\"\"\nchosen_app = Kubectl(c).choose_apps(app)\nrun_command(\nc,\nf\"kubectl get deployment/{chosen_app} -o json\",\n\"| jq -r .spec.template.spec.containers[].envFrom[].configMapRef.name\",\n\"| rg -v null | xargs -I % kubectl get configmap/% -o json | jq -r .data\",\nf\"| rg {rg}\" if rg else \"\",\n)\n</code></pre>"},{"location":"spells/#conjuring.spells.k8s.pods","title":"<code>pods(c, app, replica_set=False)</code>","text":"<p>Show the pods and replica sets for an app.</p> Source code in <code>src/conjuring/spells/k8s.py</code> <pre><code>@task(help={\"replica_set\": \"Show the replica sets for an app\"})\ndef pods(c: Context, app: str, replica_set: bool = False) -&gt; None:\n\"\"\"Show the pods and replica sets for an app.\"\"\"\nkubectl = Kubectl(c)\nchosen_apps = kubectl.choose_apps(app, multi=True)\nkubectl.run_get(\"pods\", chosen_apps)\nif replica_set:\nreplica_set_names = run_lines(\nc,\nkubectl.cmd_get(\"pods\", chosen_apps),\n\"\"\"-o jsonpath='{range .items[*]}{.metadata.ownerReferences[0].name}{\"\\\\n\"}{end}'\"\"\",\n\"| sort -u\",\n)\nfor name in replica_set_names:\nrun_command(c, f\"kubectl get replicaset {name}\")\n</code></pre>"},{"location":"spells/#conjuring.spells.k8s.validate_score","title":"<code>validate_score(c)</code>","text":"<p>Validate and score files that were changed from the master branch.</p> Source code in <code>src/conjuring/spells/k8s.py</code> <pre><code>@task()\ndef validate_score(c: Context) -&gt; None:\n\"\"\"Validate and score files that were changed from the master branch.\"\"\"\n# TODO: handle branches named \"main\"\n# Continue even if there are errors\nc.run(\"git diff master.. --name-only | xargs kubeval\", warn=True)\nc.run(\"git diff master.. --name-only | xargs kubectl score\")\n</code></pre>"},{"location":"spells/#conjuring.spells.media","title":"<code>conjuring.spells.media</code>","text":"<p>Media files: remove empty dirs, clean up picture dirs, download YouTube videos, transcribe audio.</p>"},{"location":"spells/#conjuring.spells.media.categorize","title":"<code>categorize(c, organize=True, browse=True, empty=True)</code>","text":"<p>Open directories with files/photos that have to be categorized/moved/renamed.</p> Source code in <code>src/conjuring/spells/media.py</code> <pre><code>@task(\nhelp={\n\"organize\": \"Call 'organize run' before categorizing\",\n\"browse\": \"Open dir on Finder\",\n\"empty\": \"Check dirs that are not empty but should be\",\n},\n)\ndef categorize(c: Context, organize: bool = True, browse: bool = True, empty: bool = True) -&gt; None:\n\"\"\"Open directories with files/photos that have to be categorized/moved/renamed.\"\"\"\nif organize:\nc.run(\"invoke organize\")\nempty_dirs = (\n[\nPath(str(d)).expanduser()\nfor d in [\nDOWNLOADS_DIR,\nDESKTOP_DIR,\n\"~/Documents/Shared_Downloads\",\nONEDRIVE_PICTURES_DIR / \"Telegram\",\nONEDRIVE_PICTURES_DIR / \"Samsung_Gallery/Pictures/Telegram\",\nONEDRIVE_DIR / \"Documents/Mayan_Staging/Portugues\",\nONEDRIVE_DIR / \"Documents/Mayan_Staging/English\",\nONEDRIVE_DIR / \"Documents/Mayan_Staging/Deutsch\",\n]\n]\nif empty\nelse []\n)\ncurrent_year = datetime.now(tz=timezone.utc).date().year\npicture_dirs = [\nPath(ONEDRIVE_PICTURES_DIR) / f\"Camera_New/{sub}\" for sub in chain([current_year], range(2008, current_year))\n]\nfor path in chain(empty_dirs, picture_dirs):  # type: Path\nif not path.exists():\ncontinue\nhas_files = False\nfor file in path.glob(\"*\"):\nif not file.name.startswith(\".\"):\nhas_files = True\nbreak\nif not has_files:\ncontinue\nif browse:\nlast_file = run_stdout(\nc,\n\"fd . -t f --color never\",\nstr(path),\n\"| sort -ru\",\n\"| head -1\",\n)\nrun_command(c, f\"open -R {last_file!r}\")\nbreak\ntyper.echo(str(path))\n</code></pre>"},{"location":"spells/#conjuring.spells.media.cleanup","title":"<code>cleanup(c, browse=False)</code>","text":"<p>Cleanup pictures.</p> Source code in <code>src/conjuring/spells/media.py</code> <pre><code>@task\ndef cleanup(c: Context, browse: bool = False) -&gt; None:\n\"\"\"Cleanup pictures.\"\"\"\nc.run(f\"fd -H -0 -tf -i {DOT_DS_STORE} | xargs -0 rm -v\")\nc.run(f\"fd -H -0 -tf -i {DOT_NOMEDIA} | xargs -0 rm -v\")\nc.run(\"find . -mindepth 1 -type d -empty -print -delete\")\n# Unhide Picasa originals dir\nfor line in c.run(\"fd -H -t d .picasaoriginals\", pty=False).stdout.splitlines():\noriginal_dir = Path(line)\nc.run(f\"mv {original_dir} {original_dir.parent}/Picasa_Originals\")\n# Keep the original dir as the main dir and rename parent dir to \"_Copy\"\nfor line in c.run(\"fd -t d originals\", pty=False).stdout.splitlines():\noriginal_dir = Path(line)\nc.run(f\"mv {original_dir} {original_dir.parent}_Temp\")\nc.run(f\"mv {original_dir.parent} {original_dir.parent}_Copy\")\nc.run(f\"mv {original_dir.parent}_Temp {original_dir.parent}\")\n# Merge the copy dir with the main one\nfor line in run_command(c, \"fd -a -uu -t d --color never _copy\", str(ONEDRIVE_PICTURES_DIR)).stdout.splitlines():\ncopy_dir = Path(line)\noriginal_dir = Path(line.replace(\"_Copy\", \"\"))\nif original_dir.exists():\nif browse:\nc.run(f\"open '{original_dir}'\")\nc.run(f\"merge-dirs '{original_dir}' '{copy_dir}'\")\nelse:\nc.run(f\"mv '{copy_dir}' '{original_dir}'\")\n# List dirs with _Copy files\ncopy_dirs = set()\nfor line in run_command(\nc,\n\"fd -H -t f --color never _copy\",\nstr(ONEDRIVE_PICTURES_DIR),\nhide=True,\n).stdout.splitlines():\ncopy_dirs.add(Path(line).parent)\nfor dir_ in sorted(copy_dirs):\ntyper.echo(dir_)\n</code></pre>"},{"location":"spells/#conjuring.spells.media.rm_empty_dirs","title":"<code>rm_empty_dirs(c, dir_, force=False, fd=True)</code>","text":"<p>Remove some hidden files first, then remove empty dirs.</p> <p>The ending slash is needed to search OneDrive, now that its behaviour changed in macOS Monterey.</p> Source code in <code>src/conjuring/spells/media.py</code> <pre><code>@task(\nhelp={\n\"dir\": \"Directory to clean up. Default: current dir\",\n\"fd\": \"Use https://github.com/sharkdp/fd instead of 'find'\",\n\"force\": \"Delete the actual files (dotfiles are always deleted). Default: False\",\n},\niterable=[\"dir_\"],\n)\ndef rm_empty_dirs(c: Context, dir_: list[str | Path], force: bool = False, fd: bool = True) -&gt; None:\n\"\"\"Remove some hidden files first, then remove empty dirs.\n    The ending slash is needed to search OneDrive, now that its behaviour changed in macOS Monterey.\n    \"\"\"\nif not dir_:\ndir_ = [Path.cwd()]\ndirs = list({str(Path(d).expanduser().absolute()) for d in dir_})\nxargs = \"xargs -0 -n 1 rm -v\"\nfor hidden_file in [DOT_DS_STORE, DOT_NOMEDIA]:\nif fd:\nc.run(f\"fd -uu -0 -tf -i {hidden_file} {'/ '.join(dirs)}/ | {xargs}\")\nelse:\nfor one_dir in dirs:\nc.run(f\"find {one_dir}/ -type f -iname {hidden_file} -print0 | {xargs}\")\nf_option = \" \".join([f\"-f {d}/\" for d in dirs[:-1]])\ndelete_flag = \"-delete\" if force else \"\"\nrun_command(c, \"find\", f_option, f\"{dirs[-1]}/ -mindepth 1 -type d -empty -print\", delete_flag)\nif not force:\nprint_warning(\"[DRY RUN] Run with --force to actually delete the files\")\n</code></pre>"},{"location":"spells/#conjuring.spells.media.slideshow","title":"<code>slideshow(c, start_at='')</code>","text":"<p>Show pictures in the current dir with feh.</p> Source code in <code>src/conjuring/spells/media.py</code> <pre><code>@task\ndef slideshow(c: Context, start_at: str = \"\") -&gt; None:\n\"\"\"Show pictures in the current dir with feh.\"\"\"\nstart_at_option = f\"--start-at {start_at}\" if start_at else \"\"\nrun_command(c, \"feh -r -. -g 1790x1070 -B black --caption-path .\", start_at_option)\n</code></pre>"},{"location":"spells/#conjuring.spells.media.whisper","title":"<code>whisper(c, dir_)</code>","text":"<p>Transcribe multiple audio file that haven't been transcribed yet, using whisper.</p> Source code in <code>src/conjuring/spells/media.py</code> <pre><code>@task(help={\"dir_\": \"Directory with audios to transcribe\"})\ndef whisper(c: Context, dir_: str | Path) -&gt; None:\n\"\"\"Transcribe multiple audio file that haven't been transcribed yet, using whisper.\"\"\"\ndir_ = Path(dir_).expanduser()\naudios: list[Path] = []\nfor extension in AUDIO_EXTENSIONS:\naudios.extend(dir_.glob(f\"*.{extension}\"))\nfor file in audios:\ntranscript_file = file.with_suffix(\".txt\")\nif not transcript_file.exists():\nc.run(f\"whisper --language pt -f txt '{file}' --output_dir '{file.parent}'\")\ncontinue\nc.run(f\"open '{transcript_file}'\")\n</code></pre>"},{"location":"spells/#conjuring.spells.media.youtube_dl","title":"<code>youtube_dl(c, url, min_height=240, download_archive_path='')</code>","text":"<p>Download video URLs, try different low-res formats until it finds one.</p> Source code in <code>src/conjuring/spells/media.py</code> <pre><code>@task\ndef youtube_dl(c: Context, url: str, min_height: int = 240, download_archive_path: str = \"\") -&gt; None:\n\"\"\"Download video URLs, try different low-res formats until it finds one.\"\"\"\ndownload_archive_path = download_archive_path or os.environ.get(\"YOUTUBE_DL_DOWNLOAD_ARCHIVE_PATH\", \"\")\narchive_option = f\"--download-archive {download_archive_path!r}\" if download_archive_path else \"\"\nall_heights = [h for h in [240, 360, 480, 0] if h &gt;= min_height or h == 0]\nfor height in all_heights:\n# https://github.com/ytdl-org/youtube-dl#format-selection-examples\n# Download best format available but no better than the chosen height\nfmt = f\"-f 'bestvideo[height&lt;={height}]+bestaudio/best[height&lt;={height}]'\" if height else \"\"\nresult = run_command(\nc,\n\"youtube-dl --ignore-errors --restrict-filenames\",\n# \"--get-title --get-id\",\n# \"--get-thumbnail --get-description --get-duration --get-filename\",\n# \"--get-format\",\narchive_option,\nfmt,\nurl,\nwarn=True,\n)\nif result.ok or \"Unsupported URL:\" in result.stdout:\nbreak\n</code></pre>"},{"location":"spells/#conjuring.spells.mkdocs","title":"<code>conjuring.spells.mkdocs</code>","text":"<p>MkDocs spells: install, build, deploy to GitHub, serve locally.</p>"},{"location":"spells/#conjuring.spells.mkdocs.browse","title":"<code>browse(c)</code>","text":"<p>Open the static HTML docs website on your browser.</p> Source code in <code>src/conjuring/spells/mkdocs.py</code> <pre><code>@task\ndef browse(c: Context) -&gt; None:\n\"\"\"Open the static HTML docs website on your browser.\"\"\"\nc.run(\"open http://127.0.0.1:8000/\")\n</code></pre>"},{"location":"spells/#conjuring.spells.mkdocs.build","title":"<code>build(c)</code>","text":"<p>Build docs.</p> Source code in <code>src/conjuring/spells/mkdocs.py</code> <pre><code>@task\ndef build(c: Context) -&gt; None:\n\"\"\"Build docs.\"\"\"\nc.run(\"mkdocs build --strict --verbose --site-dir site\")\n</code></pre>"},{"location":"spells/#conjuring.spells.mkdocs.deploy","title":"<code>deploy(c)</code>","text":"<p>Deploy docs to GitHub pages.</p> Source code in <code>src/conjuring/spells/mkdocs.py</code> <pre><code>@task(pre=[build])\ndef deploy(c: Context) -&gt; None:\n\"\"\"Deploy docs to GitHub pages.\"\"\"\nc.run(\"mkdocs gh-deploy\")\n</code></pre>"},{"location":"spells/#conjuring.spells.mkdocs.install","title":"<code>install(c, force=False)</code>","text":"<p>Install MkDocs globally with the Material plugin. Upgrade if it already exists.</p> Source code in <code>src/conjuring/spells/mkdocs.py</code> <pre><code>@task(help={\"force\": \"Force re-installation of MkDocs.\"})\ndef install(c: Context, force: bool = False) -&gt; None:\n\"\"\"Install MkDocs globally with the Material plugin. Upgrade if it already exists.\"\"\"\nupgrade = \" || pipx upgrade mkdocs\" if force else \"\"\nc.run(f\"pipx install mkdocs{upgrade}\", warn=True)\nfor extension in EXTENSIONS:\nc.run(f\"pipx inject mkdocs {extension}\")\n# Inject the local project into the global MkDocs installation.\nif has_pyproject_toml():\nc.run(\"pipx inject mkdocs -e .\")\n</code></pre>"},{"location":"spells/#conjuring.spells.mkdocs.serve","title":"<code>serve(c)</code>","text":"<p>Start the live-reloading server to test the docs locally.</p> Source code in <code>src/conjuring/spells/mkdocs.py</code> <pre><code>@task(pre=[build])\ndef serve(c: Context) -&gt; None:\n\"\"\"Start the live-reloading server to test the docs locally.\"\"\"\nc.run(\"mkdocs serve\")\n</code></pre>"},{"location":"spells/#conjuring.spells.mkdocs.uninstall","title":"<code>uninstall(c)</code>","text":"<p>Uninstall MkDocs globally.</p> Source code in <code>src/conjuring/spells/mkdocs.py</code> <pre><code>@task\ndef uninstall(c: Context) -&gt; None:\n\"\"\"Uninstall MkDocs globally.\"\"\"\nc.run(\"pipx uninstall mkdocs\")\n</code></pre>"},{"location":"spells/#conjuring.spells.mr","title":"<code>conjuring.spells.mr</code>","text":"<p>myrepos repository management tool: grep text in repos.</p>"},{"location":"spells/#conjuring.spells.mr.MyRepos","title":"<code>MyRepos</code>  <code>dataclass</code>","text":"<p>Find and interact with myrepos config files.</p> Source code in <code>src/conjuring/spells/mr.py</code> <pre><code>@dataclass\nclass MyRepos:\n\"\"\"Find and interact with myrepos config files.\"\"\"\ncontext: Context\ndef find_configs(self, partial_name: str, echo: bool = False) -&gt; list[Path]:\n\"\"\"Find config files in the current dir or dirs above.\"\"\"\nlower_partial_name = partial_name.lower()\nglob_pattern = MRCONFIG_FILE if not lower_partial_name else f\"{MRCONFIG_FILE}*{lower_partial_name}*\"\nconfig_dir = self._find_dir_with_mrconfigs(glob_pattern)\nif not config_dir:\nmsg = f\"No {MRCONFIG_FILE}* file was found in {Path.cwd()} or its parents\"\nraise FileNotFoundError(msg)\nif not lower_partial_name:\nreturn [config_dir / MRCONFIG_FILE]\nwith self.context.cd(str(config_dir)):\nchosen = run_with_fzf(\nself.context,\n\"ls -1\",\nf\"{MRCONFIG_FILE}*\",\nquery=lower_partial_name,\nmulti=True,\necho=echo,\nhide=not echo,\n)\nreturn sorted({config_dir / c for c in chosen})\n@staticmethod\ndef _find_dir_with_mrconfigs(glob_pattern: str) -&gt; Optional[Path]:\nfor dir_ in chain([Path.cwd()], Path.cwd().parents):\nfor _ in dir_.glob(glob_pattern):\n# Exit loop on the first file found; fzf will handle the rest\nreturn dir_\nreturn None\n</code></pre>"},{"location":"spells/#conjuring.spells.mr.MyRepos.find_configs","title":"<code>find_configs(partial_name, echo=False)</code>","text":"<p>Find config files in the current dir or dirs above.</p> Source code in <code>src/conjuring/spells/mr.py</code> <pre><code>def find_configs(self, partial_name: str, echo: bool = False) -&gt; list[Path]:\n\"\"\"Find config files in the current dir or dirs above.\"\"\"\nlower_partial_name = partial_name.lower()\nglob_pattern = MRCONFIG_FILE if not lower_partial_name else f\"{MRCONFIG_FILE}*{lower_partial_name}*\"\nconfig_dir = self._find_dir_with_mrconfigs(glob_pattern)\nif not config_dir:\nmsg = f\"No {MRCONFIG_FILE}* file was found in {Path.cwd()} or its parents\"\nraise FileNotFoundError(msg)\nif not lower_partial_name:\nreturn [config_dir / MRCONFIG_FILE]\nwith self.context.cd(str(config_dir)):\nchosen = run_with_fzf(\nself.context,\n\"ls -1\",\nf\"{MRCONFIG_FILE}*\",\nquery=lower_partial_name,\nmulti=True,\necho=echo,\nhide=not echo,\n)\nreturn sorted({config_dir / c for c in chosen})\n</code></pre>"},{"location":"spells/#conjuring.spells.mr.grep","title":"<code>grep(c, search_text, config='', echo=False)</code>","text":"<p>Grep mr repositories with a search text and print the directories in which the text was found.</p> <p>Needs mr to be preconfigured with files starting with the \".mrconfig\" prefix.</p> Source code in <code>src/conjuring/spells/mr.py</code> <pre><code>@task(\nhelp={\n\"config\": f\"Specific config file to use. Use fzf if multiple are found. Default: {MRCONFIG_FILE}\",\n\"echo\": \"Echo the commands being executed, for debugging purposes. Default: False\",\n},\n)\ndef grep(c: Context, search_text: str, config: str = \"\", echo: bool = False) -&gt; None:\n\"\"\"Grep mr repositories with a search text and print the directories in which the text was found.\n    Needs mr to be preconfigured with files starting with the \".mrconfig\" prefix.\n    \"\"\"\nfor chosen in MyRepos(c).find_configs(config, echo=echo):\n# For some reason, using run_command() prints a \"\\r\" char at the end of each line;\n# the solution is to get output as a string and use print().\noutput_without_linefeed = run_stdout(\nc,\n\"mr -c\",\nstr(chosen),\n\"-m grep\",\nsearch_text,\n\"| rg --color=never 'mr grep: (.+)$' --replace '$1'\",\necho=echo,\n)\ntyper.echo(output_without_linefeed)\n</code></pre>"},{"location":"spells/#conjuring.spells.onedrive","title":"<code>conjuring.spells.onedrive</code>","text":"<p>OneDrive: list files with conflicts.</p>"},{"location":"spells/#conjuring.spells.onedrive.conflicts","title":"<code>conflicts(c, dir_)</code>","text":"<p>List files with conflicts.</p> Source code in <code>src/conjuring/spells/onedrive.py</code> <pre><code>@task(\nhelp={\"dir\": \"Directory; can be used multiple times. Default: current dir\"},\niterable=[\"dir_\"],\n)\ndef conflicts(c: Context, dir_: list[str | Path]) -&gt; None:\n\"\"\"List files with conflicts.\"\"\"\nif not dir_:\ndir_ = [Path.cwd()]\nhostname = run_stdout(c, \"hostname -s\").strip()\nsuffix = f\"-{hostname}\"\nfor one_dir in list({str(Path(d).expanduser().absolute()) for d in dir_}):\nfor line in run_lines(c, f\"fd -t f {hostname} {one_dir} | sort\"):\nduplicated = Path(line)\noriginal_name = duplicated.stem[: -len(suffix)]\noriginal = duplicated.with_stem(original_name)\ntyper.echo(run_stdout(c, f\"diff {duplicated} {original}\", warn=True).strip())\n</code></pre>"},{"location":"spells/#conjuring.spells.paperless","title":"<code>conjuring.spells.paperless</code>","text":"<p>Paperless: maintenance, renamer, sanity, delete duplicates.</p>"},{"location":"spells/#conjuring.spells.paperless.Document","title":"<code>Document</code>  <code>dataclass</code>","text":"<p>A paperless document.</p> Source code in <code>src/conjuring/spells/paperless.py</code> <pre><code>@dataclass\nclass Document:\n\"\"\"A paperless document.\"\"\"\ndocument_id: int\ntitle: str\nerrors: list = field(default_factory=list, init=False)\n</code></pre>"},{"location":"spells/#conjuring.spells.paperless.OrphanFile","title":"<code>OrphanFile</code>  <code>dataclass</code>","text":"<p>A paperless orphan file.</p> Source code in <code>src/conjuring/spells/paperless.py</code> <pre><code>@dataclass\nclass OrphanFile:\n\"\"\"A paperless orphan file.\"\"\"\nsource: Path\ndestination: Path\ndef __lt__(self, other: OrphanFile) -&gt; bool:\nreturn self.source &lt; other.source\n</code></pre>"},{"location":"spells/#conjuring.spells.paperless.delete_failed_duplicates","title":"<code>delete_failed_duplicates(c, max_delete=100)</code>","text":"<p>Delete records marked as duplicate but that cannot be downloaded. So the PDF files can be reimported.</p> Source code in <code>src/conjuring/spells/paperless.py</code> <pre><code>@task\ndef delete_failed_duplicates(c: Context, max_delete: int = 100) -&gt; None:\n\"\"\"Delete records marked as duplicate but that cannot be downloaded. So the PDF files can be reimported.\"\"\"\nsession = requests.Session()\nsession.headers.update({\"authorization\": f\"token {paperless_token()}\"})\ndelete_count = 0\nreq_tasks = session.get(f\"{paperless_url()}/api/tasks/?format=json\")\nfor obj in req_tasks.json():\nif obj[\"status\"] != \"FAILURE\":\ncontinue\nraw_line = obj[\"result\"]\nif DUPLICATE_OF not in raw_line:\nprint_error(f\"Unknown error: {raw_line}\")\ncontinue\nclean_line = raw_line.replace(\" Not consuming \", \"\").replace(DUPLICATE_OF, \"\")\nfirst, second, duplicate_with_id = clean_line.split(\":\", maxsplit=2)\nif first != second:\nprint_error(f\"Files are different: {first=} / {second=}\")\nmatch = REGEX_TITLE_WITH_ID.match(duplicate_with_id)\nif not match:\nprint_error(f\"Line doesn't match regex {duplicate_with_id=}\", clean_line)\ncontinue\ndata = match.groupdict()\ndocument_id = data[\"id\"]\napi_document_url = f\"{paperless_url()}/api/documents/{document_id}/\"\ndocument_url = f\"{paperless_url()}/documents/{document_id}\"\nurl = f\"{api_document_url}download/\"\nreq_download = session.head(url)\nif req_download.status_code != HTTPStatus.NOT_FOUND:\nprint_success(document_url, f\"Document exists {req_download.status_code=}\", clean_line)\ncontinue\nreq_document = session.head(api_document_url)\nif req_document.status_code == HTTPStatus.NOT_FOUND:\nprint_warning(document_url, \"Document already deleted before\", clean_line)\ncontinue\nreq_delete = session.delete(api_document_url)\nif req_delete.status_code == HTTPStatus.NO_CONTENT:\nprint_success(document_url, f\"Document deleted #{delete_count}\", clean_line)\ndelete_count += 1\nif delete_count &gt;= max_delete:\nraise SystemExit\ncontinue\nprint_error(document_url, clean_line, f\"Something wrong: {req_delete.status_code=}\")\nc.run(f\"open {document_url}\")\n</code></pre>"},{"location":"spells/#conjuring.spells.paperless.maintenance","title":"<code>maintenance(c, reindex=True, optimize=True, thumbnails=True)</code>","text":"<p>Reindex all docs and optionally optimize them.</p> <p>https://docs.paperless-ngx.com/administration/#index https://docs.paperless-ngx.com/administration/#thumbnails</p> Source code in <code>src/conjuring/spells/paperless.py</code> <pre><code>@task\ndef maintenance(c: Context, reindex: bool = True, optimize: bool = True, thumbnails: bool = True) -&gt; None:\n\"\"\"Reindex all docs and optionally optimize them.\n    https://docs.paperless-ngx.com/administration/#index\n    https://docs.paperless-ngx.com/administration/#thumbnails\n    \"\"\"\nif reindex:\nc.run(f\"{paperless_cmd()} document_index reindex\")\nif optimize:\nc.run(f\"{paperless_cmd()} document_index optimize\")\nif thumbnails:\nc.run(f\"{paperless_cmd()} document_thumbnails\")\n</code></pre>"},{"location":"spells/#conjuring.spells.paperless.paperless_cmd","title":"<code>paperless_cmd()</code>","text":"<p>Command to run Paperless with Docker.</p> Source code in <code>src/conjuring/spells/paperless.py</code> <pre><code>def paperless_cmd() -&gt; str:\n\"\"\"Command to run Paperless with Docker.\"\"\"\nyaml_file = lazy_env_variable(\"PAPERLESS_COMPOSE_YAML\", \"path to the Paperless Docker compose YAML file\")\nreturn f\"docker compose -f {yaml_file} exec webserver\"\n</code></pre>"},{"location":"spells/#conjuring.spells.paperless.paperless_documents_dir","title":"<code>paperless_documents_dir()</code>","text":"<p>Directory where Paperless stores documents.</p> Source code in <code>src/conjuring/spells/paperless.py</code> <pre><code>def paperless_documents_dir() -&gt; Path:\n\"\"\"Directory where Paperless stores documents.\"\"\"\ndocuments_dir = lazy_env_variable(\"PAPERLESS_MEDIA_DOCUMENTS_DIR\", \"directory where Paperless stores documents\")\nreturn Path(documents_dir).expanduser()\n</code></pre>"},{"location":"spells/#conjuring.spells.paperless.paperless_token","title":"<code>paperless_token()</code>","text":"<p>Auth token to access Paperless API.</p> Source code in <code>src/conjuring/spells/paperless.py</code> <pre><code>def paperless_token() -&gt; str:\n\"\"\"Auth token to access Paperless API.\"\"\"\nreturn lazy_env_variable(\"PAPERLESS_TOKEN\", \"auth token to access Paperless API\")\n</code></pre>"},{"location":"spells/#conjuring.spells.paperless.paperless_url","title":"<code>paperless_url()</code>","text":"<p>URL where Paperless is running.</p> Source code in <code>src/conjuring/spells/paperless.py</code> <pre><code>def paperless_url() -&gt; str:\n\"\"\"URL where Paperless is running.\"\"\"\nreturn lazy_env_variable(\"PAPERLESS_URL\", \"URL where Paperless is running\")\n</code></pre>"},{"location":"spells/#conjuring.spells.paperless.rename","title":"<code>rename(c)</code>","text":"<p>Rename files.</p> <p>https://docs.paperless-ngx.com/administration/#renamer</p> Source code in <code>src/conjuring/spells/paperless.py</code> <pre><code>@task\ndef rename(c: Context) -&gt; None:\n\"\"\"Rename files.\n    https://docs.paperless-ngx.com/administration/#renamer\n    \"\"\"\nc.run(f\"{paperless_cmd()} document_renamer\")\n</code></pre>"},{"location":"spells/#conjuring.spells.paperless.sanity","title":"<code>sanity(c, hide=True, orphans=False, thumbnails=False, documents=False, unknown=True, together=False, fix=False, move=False)</code>","text":"<p>Sanity checker. Optionally fix orphan files (copies or movies them to the download dir).</p> <p>https://docs.paperless-ngx.com/administration/#sanity-checker</p> Source code in <code>src/conjuring/spells/paperless.py</code> <pre><code>@task(\nhelp={\n\"hide\": \"Hide progress bar of sanity command\",\n\"orphans\": \"Show orphan files\",\n\"thumbnails\": \"Show thumbnail files\",\n\"documents\": \"Show documents with issues\",\n\"unknown\": \"Show unknown lines from the log\",\n\"together\": f\"Keep {ORPHAN_ORIGINALS} and {ORPHAN_ARCHIVE} in the same output directory\",\n\"fix\": \"Fix broken files by copying them to the downloads dir\",\n\"move\": \"Move files instead of copying\",\n},\n)\ndef sanity(  # noqa: PLR0913\nc: Context,\nhide: bool = True,\norphans: bool = False,\nthumbnails: bool = False,\ndocuments: bool = False,\nunknown: bool = True,\ntogether: bool = False,\nfix: bool = False,\nmove: bool = False,\n) -&gt; None:\n\"\"\"Sanity checker. Optionally fix orphan files (copies or movies them to the download dir).\n    https://docs.paperless-ngx.com/administration/#sanity-checker\n    \"\"\"\n# Fail fast if the env var is not set\ndocuments_dir = paperless_documents_dir() if fix else None\nif documents_dir and not documents_dir.exists():\nmsg = f\"Documents directory doesn't exist: {documents_dir}\"\nraise RuntimeError(msg)\n# TODO: fix(paperless): implement dry-run mode with dry=False and actually avoid files being copied/moved\nlines = run_lines(c, paperless_cmd(), \"document_sanity_checker\", hide=hide, warn=True, pty=True)\nprogress_bar: list[str] = []\noriginal_or_archive_files: dict[str, list[OrphanFile]] = defaultdict(list)\nmatched_files: list[OrphanFile] = []\nunmatched_files: list[OrphanFile] = []\norphan_files: list[str] = []\nthumbnail_files: list[str] = []\ncurrent_document: Document | None = None\ndocuments_with_issues: list[Document] = []\nunknown_lines = []\nfor line in lines:\nif \"it/s]\" in line:\nprogress_bar.append(line)\ncontinue\nif (msg := \"Orphaned file in media dir: \") in line:\npartial_path = Path(line.split(msg)[1].replace(USR_SRC_DOCUMENTS, \"\"))\n_process_orphans(partial_path, documents_dir, original_or_archive_files, orphan_files, thumbnail_files)\ncontinue\nif (msg := \"Detected following issue(s) with document #\") in line:\n# Append the previous document\nif current_document:\ndocuments_with_issues.append(current_document)\ndocument_id, title = line.split(msg)[1].split(\", titled \")\ncurrent_document = Document(int(document_id), title)\ncontinue\nif current_document:\n_, error = line.split(\"[paperless.sanity_checker] \")\ncurrent_document.errors.append(error)\ncontinue\nunknown_lines.append(line)\n_split_matched_unmatched(original_or_archive_files, matched_files, unmatched_files, together)\n_handle_items(fix, move, orphans, \"Matched files\", matched_files)\n_handle_items(fix, move, orphans, \"Unmatched files\", unmatched_files)\n_handle_items(False, move, orphans, \"Orphan files\", orphan_files)\n# TODO: feat(paperless): move thumbnail files to downloads dir\n_handle_items(fix, move, thumbnails, \"Thumbnail files\", thumbnail_files)\n_handle_items(False, move, documents, \"Documents with issues\", documents_with_issues)\n_handle_items(False, move, unknown, \"Unknown lines\", unknown_lines)\n</code></pre>"},{"location":"spells/#conjuring.spells.pre_commit","title":"<code>conjuring.spells.pre_commit</code>","text":"<p>pre-commit: install, uninstall, run/autoupdate selected hooks.</p>"},{"location":"spells/#conjuring.spells.pre_commit.auto","title":"<code>auto(c, repo='', bleed=False)</code>","text":"<p>Autoupdate a Git hook or all hooks with the latest tag. Needs fzf and yq.</p> Source code in <code>src/conjuring/spells/pre_commit.py</code> <pre><code>@task()\ndef auto(c: Context, repo: str = \"\", bleed: bool = False) -&gt; None:\n\"\"\"Autoupdate a Git hook or all hooks with the latest tag. Needs fzf and yq.\"\"\"\ncommand = \"\"\nif repo:\nchosen = run_with_fzf(c, \"yq e '.repos[].repo' .pre-commit-config.yaml\", query=repo, dry=False)\ncommand = f\"--repo {chosen}\"\nrun_command(c, \"pre-commit autoupdate\", \"--bleeding-edge\" if bleed else \"\", command)\n</code></pre>"},{"location":"spells/#conjuring.spells.pre_commit.get_hook_types","title":"<code>get_hook_types(commit_msg, desired_hooks=None)</code>","text":"<p>Prepare a list of hook types to install/uninstall.</p> Source code in <code>src/conjuring/spells/pre_commit.py</code> <pre><code>def get_hook_types(commit_msg: bool, desired_hooks: Optional[list[str]] = None) -&gt; str:\n\"\"\"Prepare a list of hook types to install/uninstall.\"\"\"\nhooks = [\"pre-commit\"]\nif desired_hooks:\nhooks.extend(desired_hooks)\nif commit_msg:\nhooks.append(\"commit-msg\")\nhooks.append(\"prepare-commit-msg\")\nreturn \" \".join([f\"--hook-type {h}\" for h in hooks])\n</code></pre>"},{"location":"spells/#conjuring.spells.pre_commit.install","title":"<code>install(c, gc=False, commit_msg=True)</code>","text":"<p>Pre-commit install hooks.</p> Source code in <code>src/conjuring/spells/pre_commit.py</code> <pre><code>@task(help={\"gc\": \"Run the garbage collector to remove unused venvs\", \"commit_msg\": \"Install commit message hooks\"})\ndef install(c: Context, gc: bool = False, commit_msg: bool = True) -&gt; None:\n\"\"\"Pre-commit install hooks.\"\"\"\nif gc:\n_run_garbage_collector(c)\nc.run(f\"pre-commit install {get_hook_types(commit_msg)} --install-hooks\")\n</code></pre>"},{"location":"spells/#conjuring.spells.pre_commit.run","title":"<code>run(c, hooks)</code>","text":"<p>Pre-commit run all hooks or a specific one. Don't stop on failures. Needs fzf and yq.</p> Source code in <code>src/conjuring/spells/pre_commit.py</code> <pre><code>@task(\nhelp={\n\"hooks\": \"Comma-separated list of partial hook IDs (fzf will be used to match them).\"\n\" Use 'all', '.' or '-' to run all hooks.\",\n},\n)\ndef run(c: Context, hooks: str) -&gt; None:\n\"\"\"Pre-commit run all hooks or a specific one. Don't stop on failures. Needs fzf and yq.\"\"\"\nsplit_hooks = hooks.split(\",\")\nchosen_hooks = []\nfor special in (\"all\", \".\", \"-\"):\nif special in split_hooks:\nchosen_hooks.append(\"\")\nbreak\nif not chosen_hooks:\nfor partial_hook in split_hooks:\nchosen_hooks.append(\nrun_with_fzf(c, \"yq e '.repos[].hooks[].id' .pre-commit-config.yaml\", query=partial_hook, dry=False),\n)\nfor chosen_hook in chosen_hooks:\nrun_command(c, \"pre-commit run --all-files\", chosen_hook, warn=True)\n</code></pre>"},{"location":"spells/#conjuring.spells.pre_commit.uninstall","title":"<code>uninstall(c, gc=False, commit_msg=True)</code>","text":"<p>Pre-commit uninstall ALL hooks.</p> Source code in <code>src/conjuring/spells/pre_commit.py</code> <pre><code>@task(help={\"gc\": \"Run the garbage collector to remove unused venvs\", \"commit_msg\": \"Uninstall commit message hooks\"})\ndef uninstall(c: Context, gc: bool = False, commit_msg: bool = True) -&gt; None:\n\"\"\"Pre-commit uninstall ALL hooks.\"\"\"\nif gc:\n_run_garbage_collector(c)\ninstalled_hooks = [hook for hook in run_stdout(c, \"ls .git/hooks\", dry=False).splitlines() if \".sample\" not in hook]\nc.run(f\"pre-commit uninstall {get_hook_types(commit_msg, installed_hooks)}\")\n</code></pre>"},{"location":"spells/#conjuring.spells.py","title":"<code>conjuring.spells.py</code>","text":"<p>Python and Poetry.</p> <p>Install venvs, run tests and coverage, install debug tools, generate Ruff config.</p>"},{"location":"spells/#conjuring.spells.py.Poetry","title":"<code>Poetry</code>  <code>dataclass</code>","text":"<p>Poetry-related tasks.</p> Source code in <code>src/conjuring/spells/py.py</code> <pre><code>@dataclass()\nclass Poetry:\n\"\"\"Poetry-related tasks.\"\"\"\ncontext: Context\ndef used_in_project(self, display_error: bool = True) -&gt; bool:\n\"\"\"Check if Poetry is being used.\"\"\"\nused = int(\nrun_command(\nself.context,\nf\"grep tool.poetry {PYPROJECT_TOML} 2&gt;/dev/null | wc -c\",\nhide=True,\nwarn=True,\n).stdout.strip(),\n)\nif not used and display_error:\nprint_error(\"This task only works with Poetry projects (so far).\")\nreturn bool(used)\n@staticmethod\ndef parse_python_version(venv: str) -&gt; str:\n\"\"\"For now, assuming we only have Poetry venvs.\"\"\"\nreturn venv.split(\" \")[0].split(\"-py\")[1]\ndef remove_venv(self, python_version: str) -&gt; Result:\n\"\"\"Remove a Poetry venv.\"\"\"\nreturn self.context.run(f\"poetry env remove python{python_version}\")\ndef guess_python_version(self) -&gt; str:\n\"\"\"Guess Python version from pyproject.toml.\"\"\"\n# TODO: rewrite this hack and use a TOML package to read the values directly\npyproject_lines = run_lines(\nself.context,\nf\"rg --no-line-number -e '^python ' -e python_version {PYPROJECT_TOML}\",\n)\nversions: set[str] = set()\nfor line in pyproject_lines:\nvalue_with_comment = line.split(\"=\")[1]\nvalue_only = value_with_comment.split(\"#\")[0]\nclean_version = value_only.replace(\"^\", \"\").replace(\"~\", \"\").strip('\" ')\nversions.add(clean_version)\nif len(versions) &gt; 1:\nprint_error(f\"Multiple Python versions found in {PYPROJECT_TOML}: {versions=}\")\nraise SystemExit\nreturn list(versions)[0]\ndef use_venv(self, python_version: str) -&gt; Result:\n\"\"\"Use a Poetry venv.\"\"\"\nreturn self.context.run(f\"poetry env use python{python_version}\")\n</code></pre>"},{"location":"spells/#conjuring.spells.py.Poetry.guess_python_version","title":"<code>guess_python_version()</code>","text":"<p>Guess Python version from pyproject.toml.</p> Source code in <code>src/conjuring/spells/py.py</code> <pre><code>def guess_python_version(self) -&gt; str:\n\"\"\"Guess Python version from pyproject.toml.\"\"\"\n# TODO: rewrite this hack and use a TOML package to read the values directly\npyproject_lines = run_lines(\nself.context,\nf\"rg --no-line-number -e '^python ' -e python_version {PYPROJECT_TOML}\",\n)\nversions: set[str] = set()\nfor line in pyproject_lines:\nvalue_with_comment = line.split(\"=\")[1]\nvalue_only = value_with_comment.split(\"#\")[0]\nclean_version = value_only.replace(\"^\", \"\").replace(\"~\", \"\").strip('\" ')\nversions.add(clean_version)\nif len(versions) &gt; 1:\nprint_error(f\"Multiple Python versions found in {PYPROJECT_TOML}: {versions=}\")\nraise SystemExit\nreturn list(versions)[0]\n</code></pre>"},{"location":"spells/#conjuring.spells.py.Poetry.parse_python_version","title":"<code>parse_python_version(venv)</code>  <code>staticmethod</code>","text":"<p>For now, assuming we only have Poetry venvs.</p> Source code in <code>src/conjuring/spells/py.py</code> <pre><code>@staticmethod\ndef parse_python_version(venv: str) -&gt; str:\n\"\"\"For now, assuming we only have Poetry venvs.\"\"\"\nreturn venv.split(\" \")[0].split(\"-py\")[1]\n</code></pre>"},{"location":"spells/#conjuring.spells.py.Poetry.remove_venv","title":"<code>remove_venv(python_version)</code>","text":"<p>Remove a Poetry venv.</p> Source code in <code>src/conjuring/spells/py.py</code> <pre><code>def remove_venv(self, python_version: str) -&gt; Result:\n\"\"\"Remove a Poetry venv.\"\"\"\nreturn self.context.run(f\"poetry env remove python{python_version}\")\n</code></pre>"},{"location":"spells/#conjuring.spells.py.Poetry.use_venv","title":"<code>use_venv(python_version)</code>","text":"<p>Use a Poetry venv.</p> Source code in <code>src/conjuring/spells/py.py</code> <pre><code>def use_venv(self, python_version: str) -&gt; Result:\n\"\"\"Use a Poetry venv.\"\"\"\nreturn self.context.run(f\"poetry env use python{python_version}\")\n</code></pre>"},{"location":"spells/#conjuring.spells.py.Poetry.used_in_project","title":"<code>used_in_project(display_error=True)</code>","text":"<p>Check if Poetry is being used.</p> Source code in <code>src/conjuring/spells/py.py</code> <pre><code>def used_in_project(self, display_error: bool = True) -&gt; bool:\n\"\"\"Check if Poetry is being used.\"\"\"\nused = int(\nrun_command(\nself.context,\nf\"grep tool.poetry {PYPROJECT_TOML} 2&gt;/dev/null | wc -c\",\nhide=True,\nwarn=True,\n).stdout.strip(),\n)\nif not used and display_error:\nprint_error(\"This task only works with Poetry projects (so far).\")\nreturn bool(used)\n</code></pre>"},{"location":"spells/#conjuring.spells.py.PyEnv","title":"<code>PyEnv</code>  <code>dataclass</code>","text":"<p>pyenv-related tasks.</p> Source code in <code>src/conjuring/spells/py.py</code> <pre><code>@dataclass\nclass PyEnv:\n\"\"\"pyenv-related tasks.\"\"\"\ncontext: Context\ndef has_local(self) -&gt; bool:\n\"\"\"Check if a local Python version is set.\"\"\"\noutput = self.context.run(\"pyenv local\", warn=True).stdout.strip()\nreturn output and \"no local version\" not in output\ndef set_local(self, python_version: str) -&gt; Result:\n\"\"\"Set the local pyenv version.\"\"\"\nlatest = self.list_versions(python_version)[-1]\nreturn self.context.run(f\"pyenv local {latest}\")\ndef list_versions(self, python_version: Optional[str] = None) -&gt; list[str]:\n\"\"\"List all installed Python versions, or only the ones matching the desired version.\"\"\"\nall_versions = run_lines(self.context, \"pyenv versions --bare\")\nif not python_version:\nreturn all_versions\nreturn [version for version in all_versions if version.startswith(python_version)]\n</code></pre>"},{"location":"spells/#conjuring.spells.py.PyEnv.has_local","title":"<code>has_local()</code>","text":"<p>Check if a local Python version is set.</p> Source code in <code>src/conjuring/spells/py.py</code> <pre><code>def has_local(self) -&gt; bool:\n\"\"\"Check if a local Python version is set.\"\"\"\noutput = self.context.run(\"pyenv local\", warn=True).stdout.strip()\nreturn output and \"no local version\" not in output\n</code></pre>"},{"location":"spells/#conjuring.spells.py.PyEnv.list_versions","title":"<code>list_versions(python_version=None)</code>","text":"<p>List all installed Python versions, or only the ones matching the desired version.</p> Source code in <code>src/conjuring/spells/py.py</code> <pre><code>def list_versions(self, python_version: Optional[str] = None) -&gt; list[str]:\n\"\"\"List all installed Python versions, or only the ones matching the desired version.\"\"\"\nall_versions = run_lines(self.context, \"pyenv versions --bare\")\nif not python_version:\nreturn all_versions\nreturn [version for version in all_versions if version.startswith(python_version)]\n</code></pre>"},{"location":"spells/#conjuring.spells.py.PyEnv.set_local","title":"<code>set_local(python_version)</code>","text":"<p>Set the local pyenv version.</p> Source code in <code>src/conjuring/spells/py.py</code> <pre><code>def set_local(self, python_version: str) -&gt; Result:\n\"\"\"Set the local pyenv version.\"\"\"\nlatest = self.list_versions(python_version)[-1]\nreturn self.context.run(f\"pyenv local {latest}\")\n</code></pre>"},{"location":"spells/#conjuring.spells.py.Pytest","title":"<code>Pytest</code>","text":"<p>Pytest-related tasks.</p> Source code in <code>src/conjuring/spells/py.py</code> <pre><code>class Pytest:\n\"\"\"Pytest-related tasks.\"\"\"\n@staticmethod\ndef command(s: bool) -&gt; str:\n\"\"\"Build pytest command.\"\"\"\ncommand = \"pytest -v\"\nif s:\ncommand += \" -s\"\nreturn command\n</code></pre>"},{"location":"spells/#conjuring.spells.py.Pytest.command","title":"<code>command(s)</code>  <code>staticmethod</code>","text":"<p>Build pytest command.</p> Source code in <code>src/conjuring/spells/py.py</code> <pre><code>@staticmethod\ndef command(s: bool) -&gt; str:\n\"\"\"Build pytest command.\"\"\"\ncommand = \"pytest -v\"\nif s:\ncommand += \" -s\"\nreturn command\n</code></pre>"},{"location":"spells/#conjuring.spells.py.coverage","title":"<code>coverage(c, show_all=False, s=False)</code>","text":"<p>Run tests with pytest and coverage.</p> Source code in <code>src/conjuring/spells/py.py</code> <pre><code>@task(\nhelp={\n\"show_all\": \"Show all lines, even if they are covered\",\n\"s\": \"Don't capture output (same shortcut as pytest)\",\n},\n)\ndef coverage(c: Context, show_all: bool = False, s: bool = False) -&gt; None:\n\"\"\"Run tests with pytest and coverage.\"\"\"\nif not Poetry(c).used_in_project():\nreturn\noptions = [f\"--cov={source}\" for source in [\"src\", Path.cwd().name, \"app\"] if Path(source).exists()]\nskip_option = \"\" if show_all else \":skip-covered\"\noptions.append(f\"--cov-report=term-missing{skip_option}\")\nrun_command(c, \"poetry run\", Pytest.command(s), *options)\n</code></pre>"},{"location":"spells/#conjuring.spells.py.debug_tools","title":"<code>debug_tools(c, all_=False, ipython=False, ipdb=False, pudb=False, icecream=False, devtools=False, watch=False, watcher=False)</code>","text":"<p>Install debug tools.</p> Source code in <code>src/conjuring/spells/py.py</code> <pre><code>@task(\nhelp={\n\"all_\": \"Install all debug tools\",\n\"ipython\": \"Install https://pypi.org/project/ipython/\",\n\"ipdb\": \"Install https://pypi.org/project/ipdb/\",\n\"pudb\": \"Install https://pypi.org/project/pudb/\",\n\"icecream\": \"Install https://pypi.org/project/icecream/\",\n\"devtools\": \"Install https://pypi.org/project/devtools/\",\n\"watch\": \"Install https://github.com/joeyespo/pytest-watch\",\n\"watcher\": \"Install https://github.com/olzhasar/pytest-watcher\",\n},\n)\ndef debug_tools(  # noqa: PLR0913\nc: Context,\nall_: bool = False,\nipython: bool = False,\nipdb: bool = False,\npudb: bool = False,\nicecream: bool = False,\ndevtools: bool = False,\nwatch: bool = False,\nwatcher: bool = False,\n) -&gt; None:\n\"\"\"Install debug tools.\"\"\"\nif not Poetry(c).used_in_project():\nreturn\nif watch and watcher:\nprint_error(\"Use only one of --watch and --watcher.\")\nreturn\nif watch:\nc.run(\"poetry run python -m pip uninstall -y pytest-watcher\")\nelif watcher:\nc.run(\"poetry run python -m pip uninstall -y pytest-watch\")\ntools = [\n\"pip\",\n\"ipython\" if ipython or all_ else \"\",\n\"ipdb\" if ipdb or all_ else \"\",\n\"pudb\" if pudb or all_ else \"\",\n\"icecream\" if icecream or all_ else \"\",\n\"devtools[pygments]\" if devtools or all_ else \"\",\n\"pytest-watch\" if watch or all_ else \"\",\n\"pytest-watcher\" if watcher or all_ else \"\",\n]\nrun_command(c, \"poetry run pip install --upgrade\", *tools)\n</code></pre>"},{"location":"spells/#conjuring.spells.py.editable","title":"<code>editable(c, inject='')</code>","text":"<p>Hack to install a Poetry package as editable until Poetry supports PEP660 hooks.</p> <p>It won't be needed anymore when https://github.com/python-poetry/poetry-core/pull/182 is merged.</p> Source code in <code>src/conjuring/spells/py.py</code> <pre><code>@task(help={\"inject\": \"Pipx repo to inject this project into\"})\ndef editable(c: Context, inject: str = \"\") -&gt; None:\n\"\"\"Hack to install a Poetry package as editable until Poetry supports PEP660 hooks.\n    It won't be needed anymore when https://github.com/python-poetry/poetry-core/pull/182 is merged.\n    \"\"\"\nif not Poetry(c).used_in_project():\nreturn\nchosen_repo = \"\"\nif inject:\n# Ask for the repo before doing anything else... to fail fast if no repo is chosen\nchosen_repo = run_with_fzf(c, \"ls -1 ~/.local/pipx/venvs/\", query=inject)\nif not chosen_repo:\nreturn\nc.run(\"poetry build\")\nc.run(\"tar -xvzf dist/*.gz --strip-components 1 */setup.py\")\n# Ignore errors, it might not be installed\nc.run(\"black setup.py\", warn=True)\nif not chosen_repo:\nprint_error(\"Use --inject to inject this repo into a pipx virtualenv.\")\nreturn\nc.run(f\"mv {PYPROJECT_TOML} _{PYPROJECT_TOML}\")\nrun_command(c, \"pipx inject -e\", chosen_repo, \".\")\nc.run(f\"mv _{PYPROJECT_TOML} {PYPROJECT_TOML}\")\nc.run(\"rm setup.py\")\n</code></pre>"},{"location":"spells/#conjuring.spells.py.install","title":"<code>install(c, version='', force=False, delete_all=False, pipx=False, editable=False)</code>","text":"<p>Install a Python virtual environment. For now, only works with Poetry.</p> Source code in <code>src/conjuring/spells/py.py</code> <pre><code>@task(\nhelp={\n\"version\": \"Python version\",\n\"force\": \"Recreate the environment\",\n\"delete_all\": \"Delete all environments\",\n\"pipx\": \"Install with pipx\",\n\"editable\": \"Install as editable\",\n},\n)\ndef install(  # noqa: PLR0913\nc: Context,\nversion: str = \"\",\nforce: bool = False,\ndelete_all: bool = False,\npipx: bool = False,\neditable: bool = False,\n) -&gt; None:\n\"\"\"Install a Python virtual environment. For now, only works with Poetry.\"\"\"\nvenv_list = run_lines(c, \"poetry env list\", hide=False)\npoetry = Poetry(c)\nif not poetry.used_in_project():\nreturn\nif delete_all:\nfor venv_name in venv_list:\nif \".venv\" in venv_name:\nc.run(\"rm -rf .venv\")\nelse:\npoetry.remove_venv(poetry.parse_python_version(venv_name))\nif not version:\nversion = poetry.guess_python_version()\npyenv = PyEnv(c)\nif force or not pyenv.has_local():\n# TODO: if tox.ini is present in the repo, set all versions from there\npyenv.set_local(version)\nif force and not delete_all:\npoetry.remove_venv(version)\npoetry.use_venv(version)\nc.run(\"poetry lock --check &amp;&amp; poetry install\")\nif pipx:\nrun_command(c, \"pipx install\", \"--python\", f\"python{version}\", \" --editable\" if editable else \"\", \".\")\nc.run(\"poetry env list\")\n</code></pre>"},{"location":"spells/#conjuring.spells.py.ruff_config","title":"<code>ruff_config(c)</code>","text":"<p>Generate ruff configuration from existing warnings.</p> Source code in <code>src/conjuring/spells/py.py</code> <pre><code>@task(klass=MagicTask)\ndef ruff_config(c: Context) -&gt; None:\n\"\"\"Generate ruff configuration from existing warnings.\"\"\"\n# TODO: feat: check if the global ruff is installed and use it if it is\nignore: dict[str, set[str]] = defaultdict(set)\nper_file_ignores: dict[str, set[str]] = defaultdict(set)\nfor line in run_lines(c, \"pre-commit run --all-files ruff\", warn=True):\nif line.startswith(\"warning:\"):\ntyper.echo(line)\ncontinue\nmatch = REGEX_RUFF_LINE.match(line)\nif not match:\ncontinue\nfilename = match.group(\"filename\")\ncode = match.group(\"code\")\nmessage = match.group(\"message\")\nclean_message = REGEX_RUFF_MESSAGE.sub(\"?\", message)\nignore[code].add(clean_message.strip())\nper_file_ignores[filename].add(code)\ndef _print_ruff_codes(ignore_section: bool) -&gt; None:\nfor _code, messages in sorted(ignore.items()):\njoined_messages = \",\".join(sorted(messages))\nif ignore_section:\ntyper.echo(f'    \"{_code}\", # {joined_messages}', nl=False)\nelse:\ntyper.echo(f\"# {_code} {joined_messages}\", nl=False)\ntyper.echo(f\" https://beta.ruff.rs/docs/rules/?q={_code}\")\n# TODO: edit pyproject.toml existing config for both sections,\n#  skipping existing lines and adding new codes at the bottom\nif ignore:\nheader = \"\"\"\n            # https://beta.ruff.rs/docs/settings/#ignore\n            ignore = [\n                # Ignores to keep\n                # TODO: Ignores to fix\n        \"\"\"\ntyper.echo(dedent(header).strip())\n_print_ruff_codes(True)\ntyper.echo(\"]\\n\")\nif per_file_ignores:\nheader = \"\"\"\n            # https://beta.ruff.rs/docs/settings/#per-file-ignores\n            [tool.ruff.per-file-ignores]\n            # Ignores to keep\n            # TODO: Ignores to fix\n        \"\"\"\ntyper.echo(dedent(header).strip())\n_print_ruff_codes(False)\nfor file, codes in sorted(per_file_ignores.items()):\nsorted_codes = '\", \"'.join(sorted(codes))\ntyper.echo(f'\"{file}\" = [\"{sorted_codes}\"]')\n</code></pre>"},{"location":"spells/#conjuring.spells.py.test","title":"<code>test(c, s=False)</code>","text":"<p>Run tests with pytest.</p> Source code in <code>src/conjuring/spells/py.py</code> <pre><code>@task(\nhelp={\n\"s\": \"Don't capture output (same shortcut as pytest)\",\n},\n)\ndef test(c: Context, s: bool = False) -&gt; None:\n\"\"\"Run tests with pytest.\"\"\"\nif not Poetry(c).used_in_project():\nreturn\nrun_command(c, \"poetry run\", Pytest.command(s))\n</code></pre>"},{"location":"spells/#conjuring.spells.py.watch","title":"<code>watch(c)</code>","text":"<p>Watch changed files and run tests with pytest.</p> Source code in <code>src/conjuring/spells/py.py</code> <pre><code>@task\ndef watch(c: Context) -&gt; None:\n\"\"\"Watch changed files and run tests with pytest.\"\"\"\nif not Poetry(c).used_in_project():\nreturn\nrun_command(c, \"poetry run\", 'ptw --runner \"pytest --testmon\"')\n</code></pre>"},{"location":"spells/#conjuring.spells.shell","title":"<code>conjuring.spells.shell</code>","text":"<p>Shell: install/uninstall completion.</p>"},{"location":"spells/#conjuring.spells.shell.completion_install","title":"<code>completion_install(c, app)</code>","text":"<p>Install shell completion. For now, only for the Bash shell, and only for Click projects.</p> <ul> <li>Shell Completion \u2014 Click Documentation (8.0.x)</li> <li>click-contrib/click-completion: Add or enhance bash, fish, zsh and powershell completion in Click</li> </ul> Source code in <code>src/conjuring/spells/shell.py</code> <pre><code>@task\ndef completion_install(c: Context, app: str) -&gt; None:\n\"\"\"Install shell completion. For now, only for the Bash shell, and only for Click projects.\n    - [Shell Completion \u2014 Click Documentation (8.0.x)](https://click.palletsprojects.com/en/8.0.x/shell-completion/)\n    - [click-contrib/click-completion: Add or enhance bash, fish, zsh and powershell completion in Click](https://github.com/click-contrib/click-completion)\n    \"\"\"\ncompletion_file = f\"{COMPAT_DIR}{app}.bash-completion\"\nc.run(f\"_{app.upper()}_COMPLETE=bash_source {app} &gt; {completion_file}\")\nc.run(f\"exa -l {completion_file}\")\nc.run(f\"bat {completion_file}\")\n</code></pre>"},{"location":"spells/#conjuring.spells.shell.completion_list","title":"<code>completion_list(c)</code>","text":"<p>List existing shell completions.</p> Source code in <code>src/conjuring/spells/shell.py</code> <pre><code>@task\ndef completion_list(c: Context) -&gt; None:\n\"\"\"List existing shell completions.\"\"\"\nfor var in COMPLETION_DIRS:\nc.run(f\"exa -l {var}\")\n</code></pre>"},{"location":"spells/#conjuring.spells.shell.completion_uninstall","title":"<code>completion_uninstall(c, app)</code>","text":"<p>Uninstall shell completion from both completion dirs.</p> Source code in <code>src/conjuring/spells/shell.py</code> <pre><code>@task\ndef completion_uninstall(c: Context, app: str) -&gt; None:\n\"\"\"Uninstall shell completion from both completion dirs.\"\"\"\nfor completion_dir in COMPLETION_DIRS:\nwith c.cd(completion_dir):\nc.run(f\"rm -v {app}*\", warn=True)\ncompletion_list(c)\n</code></pre>"}]}