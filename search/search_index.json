{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Conjuring","text":"<p>Reusable global Invoke tasks that can be merged with local project tasks.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Merge any local <code>tasks.py</code> file with global Conjuring tasks</li> <li>Use all global Conjuring tasks provided by this package</li> <li>Only include the global Conjuring tasks you want (opt-in spells)</li> <li>Use all Conjuring tasks excluding some (opt-out spells)</li> <li>Add your own custom tasks from Python modules or packages to global tasks</li> <li>Display your custom task modules conditionally</li> <li>Display your custom individual tasks conditionally</li> <li>Merge your project tasks with the global reusable tasks</li> <li>Prefix task names of your custom module</li> </ul> <p>More details on the features documentation.</p>"},{"location":"#tasks","title":"Tasks","text":"<p>Each module under the <code>conjuring/spells</code> directory is a collection of Invoke tasks.</p> <p>Read more in Spells (API reference).</p>"},{"location":"#quick-setup","title":"Quick setup","text":"<p>Install Conjuring in an isolated virtualenv with pipx:</p> <pre><code>pipx install --include-deps conjuring\n</code></pre> <p>The <code>--include-deps</code> flag is needed to install Invoke's apps (<code>invoke</code> and <code>inv</code>).</p> <p>Run the command to configure files on your home directory:</p> <pre><code># For more options:\n# conjuring init --help\nconjuring init\n</code></pre> <p>You should see the list of Conjuring tasks from any directory where you type this:</p> <pre><code>invoke --list\n</code></pre> <p>For more configuration options, read the detailed documentation.</p>"},{"location":"CHANGELOG/","title":"Changelog","text":""},{"location":"CHANGELOG/#v070-2023-05-27","title":"v0.7.0 (2023-05-27)","text":""},{"location":"CHANGELOG/#feat","title":"Feat","text":"<ul> <li>\"conjuring init\" command to set up files (#11)</li> <li>py: -s option in py.test and py.coverage</li> </ul>"},{"location":"CHANGELOG/#fix","title":"Fix","text":"<ul> <li>git: improve commit body clean-up</li> </ul>"},{"location":"CHANGELOG/#v060-2023-05-24","title":"v0.6.0 (2023-05-24)","text":""},{"location":"CHANGELOG/#feat_1","title":"Feat","text":"<ul> <li>direnv: command to init .envrc</li> </ul>"},{"location":"CHANGELOG/#refactor","title":"Refactor","text":"<ul> <li>replace print() by typer.echo()</li> <li>add typing to py and remaining tests</li> <li>add typing to mkdocs, mr, onedrive, paperless, pre-commit</li> <li>add typing and docs to some modules</li> </ul>"},{"location":"CHANGELOG/#v050-2023-05-22","title":"v0.5.0 (2023-05-22)","text":""},{"location":"CHANGELOG/#feat_2","title":"Feat","text":"<ul> <li>add global tasks from Python modules or packages</li> </ul>"},{"location":"CHANGELOG/#fix_1","title":"Fix","text":"<ul> <li>py: always show ruff-config even on non-Poetry projects</li> <li>improved messages on conjuring.init</li> </ul>"},{"location":"CHANGELOG/#v040-2023-05-21","title":"v0.4.0 (2023-05-21)","text":""},{"location":"CHANGELOG/#feat_3","title":"Feat","text":"<ul> <li>py: task to generate Ruff config from warnings</li> </ul>"},{"location":"CHANGELOG/#v030-2023-05-20","title":"v0.3.0 (2023-05-20)","text":""},{"location":"CHANGELOG/#feat_4","title":"Feat","text":"<ul> <li>choose which tasks you want to load (opt-in/opt-out)</li> </ul>"},{"location":"CHANGELOG/#v021-2023-05-20","title":"v0.2.1 (2023-05-20)","text":""},{"location":"CHANGELOG/#fix_2","title":"Fix","text":"<ul> <li>version number and project metadata</li> </ul>"},{"location":"CHANGELOG/#v020-2023-05-19","title":"v0.2.0 (2023-05-19)","text":""},{"location":"CHANGELOG/#fix_3","title":"Fix","text":"<ul> <li>read pyproject.toml with UTF-8 encoding</li> </ul>"},{"location":"CHANGELOG/#010-2023-05-19","title":"0.1.0 (2023-05-19)","text":""},{"location":"CHANGELOG/#feat_5","title":"Feat","text":"<ul> <li>media: transcribe using whisper</li> <li>mkdocs: tasks to work with documentation</li> <li>k8s: select multiple apps at once</li> <li>k8s: get pods, replica sets, config maps + validate score</li> <li>mr: add mr support, grep repos for a search text</li> <li>pre-commit: specify hooks without --hook</li> <li>python: test, watch, coverage, debug tools</li> <li>git: option to rebase master branch</li> <li>python: install/reinstall specific version</li> <li>fzf: accept options as arguments</li> <li>aws: list profiles</li> <li>allowed keys in ask_user_prompt()</li> <li>onedrive: display files with conflicts</li> <li>media: --force flag to delete files</li> <li>python: install a Poetry virtual environment</li> <li>paperless: delete failed duplicates</li> <li>remove hidden files and empty dirs</li> <li>paperless: move files instead of copying</li> <li>paperless: skip years and .DS_Store</li> <li>paperless: copy matched/unmatched files to ~/Downloads</li> <li>paperless: display orphan files, matched and unmatched</li> <li>paperless: show matched/unmatched files</li> <li>paperless: show thumbnails</li> <li>paperless: wrapper tasks for paperless</li> <li>ask user prompt</li> <li>git: prepare commit body with bullets</li> <li>git: task to tidy up repo</li> <li>pre-commit: install prepare-commit-msg</li> <li>pre-commit: uninstall all hooks</li> <li>slideshow command (first version)</li> <li>git: watch build then open PR or repo</li> <li>use AWS_PROFILE if it exists</li> <li>git: display changes since the chosen tag</li> <li>pre-commit: commit-msg hook is now optional</li> <li>shell: list and uninstall shell completions</li> <li>shell: click completion for Bash</li> <li>git: choose files with fzf, allow multiple subdirs</li> <li>download video URLs with youtube-dl</li> <li>git: merge the default branch of the repo</li> <li>git: options to rewrite commits with GPG and author</li> <li>docker: remove Docker containers and volumes</li> <li>todo: sort by type+description, option to show only FIXME</li> <li>list TODOs and FIXMEs in code</li> <li>pre-commit: accept comma-separated list of hooks to run</li> <li>git: extract files from a subtree + history + rebase/sign</li> <li>support PEP 660 hooks (editable packages)</li> <li>empty module for those who don't want the default tasks</li> <li>AWS: select account, region, ECR, aws-vault</li> <li>pre-commit: command to uninstall hooks</li> <li>poetry: choose pipx repo to inject with fzf</li> <li>display individual tasks conditionally</li> <li>visibility.py module with reusable functions</li> <li>prefix task names of a module</li> <li>display tasks conditionally</li> <li>merge any tasks.py with Conjuring tasks</li> <li>pre-commit: autoupdate one or all hooks</li> <li>use CONJURING_PREFIX to namespace tasks</li> <li>install a Poetry package as editable</li> <li>default module with all conjuring tasks</li> <li>fork tasks in a separate module</li> <li>optionally check empty dirs</li> <li>display dirs that should be emptied</li> <li>duplicity: choose a directory when restoring</li> <li>backup/restore with Duplicity</li> <li>onedrive: current year first, then others</li> <li>list dirs with _Copy files</li> <li>unhide Picasa originals dir</li> <li>merge original dirs</li> <li>merge copy dirs</li> <li>move picture dirs by year</li> <li>backup files from the m3 hard drive</li> <li>list more dirs on OneDrive</li> <li>add warn param to run_command()</li> <li>option to choose journal on tags task</li> <li>remove empty files before OneDrive dir</li> <li>open the latest N OneDrive photo dirs</li> <li>function to run with fzf</li> <li>run_command function</li> <li>ignore modules with an env var</li> <li>jrnl: journal name</li> <li>more Git helpers</li> <li>query jrnl entries and tags</li> <li>configure a generic remote</li> <li>don't add home tasks twice</li> <li>auto update nitpick</li> <li>set SSH/HTTPS URL for remote</li> <li>pre-commit install and run</li> <li>fork remote and sync</li> <li>invoke tasks for home/current dirs</li> <li>change invoke collection name</li> </ul>"},{"location":"CHANGELOG/#fix_4","title":"Fix","text":"<ul> <li>pre-commit: don't stop on the first failed hook</li> <li>deps: update dependency requests to v2.30.0</li> <li>deps: update dependency invoke to v2.1.2</li> <li>py: check lock before installing, ignore comment on version</li> <li>py: don't fail if pyenv local is not set</li> <li>git: rebase with force push, from origin</li> <li>rename to py, use venv after pyenv set local</li> <li>media: use -f as short for --force</li> <li>return user input on ask_user_prompt()</li> <li>paperless: ignore all .DS_Store, fix --together</li> <li>paperless: don't display red files that can't be checked</li> <li>git: regex to parse Jira tickets</li> <li>git: body cleanup: Jira ticket and other stuff</li> <li>duplicity: max depth when running fd in OneDrive dirs</li> <li>duplicity: uppercase $HOME</li> <li>git: shorten names for commit body command</li> <li>git: prune after deleting branches, push by default</li> <li>media: open the last file (order was random before)</li> <li>git: prune remotes before updating the repo</li> <li>git: open PR in same branch that was watched</li> <li>improved Poetry detection (#1)</li> <li>organize: call invoke task and not the tool directly</li> <li>fd flags (hidden only)</li> <li>display Conjuring tasks only on home dir</li> <li>duplicated name in main collection</li> <li>check prefix before duplicated tasks</li> <li>dry-run mode on run_command()</li> <li>remote name defaults to username</li> <li>duplicity: restore on computer subdir</li> <li>check both Telegram dirs</li> <li>move Telegram dir under Samsung Gallery</li> <li>rename organize to categorize</li> <li>convert Path to str when joining</li> <li>show Telegram dir after current year dir</li> <li>don't limit jrnl entries by default</li> <li>jrnl improvements</li> <li>allow invoke*.py files</li> <li>pty=False to remove colors</li> </ul>"},{"location":"CHANGELOG/#refactor_1","title":"Refactor","text":"<ul> <li>constants for common directories</li> <li>prefer qualified imports (#3)</li> <li>preparing for multiple spell books</li> <li>gita_super is a better name</li> <li>a more appropriate name</li> <li>move tasks to their spell modules</li> <li>move color constants to conjuring</li> <li>create package structure</li> </ul>"},{"location":"features/","title":"Features","text":""},{"location":"features/#spell-options","title":"Spell options","text":"<p>Conjuring has 4 available options for built-in spells (all, opt-in, opt-out, imported only), detailed below.</p> <p>When you run <code>conjuring init</code>, it creates an <code>~/.invoke.yaml</code> file and a <code>~/conjuring_init.py</code> on your home directory.</p> <p>This will merge any existing local <code>tasks.py</code> file with the global Conjuring tasks.</p> <p>For more details, read about default configuration values on Configuration \u2014 Invoke documentation.</p>"},{"location":"features/#all-tasks","title":"All tasks","text":"<p>To use all global Conjuring tasks provided by this package, run:</p> <pre><code>conjuring init --spells all\n</code></pre> <p>Run <code>invoke --list</code> from any directory, and you will see all Conjuring tasks.</p>"},{"location":"features/#opt-in","title":"Opt-in","text":"<p>If you want to only include the global Conjuring tasks you want, run this command and select the files with fzf:</p> <pre><code>conjuring init --spells opt-in\n</code></pre> <p>Or you can edit the Python bootstrap file manually. Suppose you only want these global tasks:</p> <ul> <li>AWS;</li> <li>Kubernetes;</li> <li>pre-commit;</li> <li>Python;</li> <li>all tasks that install anything.</li> </ul> <p>This is how you can do it:</p> <pre><code># ~/conjuring_init.py\nfrom conjuring import Spellbook\n\nnamespace = Spellbook().conjure_only(\"aws*\", \"k8s*\", \"pre-commit*\", \"py*\", \"*install\")\n</code></pre>"},{"location":"features/#opt-out","title":"Opt-out","text":"<p>To use all Conjuring modules and tasks, except for a few, run this command and select the files with fzf:</p> <pre><code>conjuring init --spells opt-out\n</code></pre> <p>Or you can edit the Python bootstrap file manually.</p> <p>Suppose you want all Conjuring tasks except media and OneDrive tasks. This is the way:</p> <pre><code># ~/conjuring_init.py\nfrom conjuring import Spellbook\n\nnamespace = Spellbook().conjure_all_except(\"media*\", \"onedrive*\")\n</code></pre>"},{"location":"features/#imported-only","title":"Imported only","text":"<p>To use only the tasks that are imported with a list of directories, run:</p> <pre><code>conjuring init --spells imported-only --dir ~/path/to/your/src --dir ~/path/to/another/src\n</code></pre> <p>These directories must contain Python modules or packages with Invoke tasks.</p>"},{"location":"features/#shell-enhancements","title":"Shell enhancements","text":"<p>Invoke can also be configured with environment variables for an even smoother experience.</p> <p>Note: this is not a Conjuring feature, it's built-in in Invoke.</p>"},{"location":"features/#echo-all-commands","title":"Echo all commands","text":"<p>Echo all commands in all tasks by default, like Make does.</p> <pre><code># ~/.bashrc, ~/.zshrc or your favourite shell\nexport INVOKE_RUN_ECHO=1\n</code></pre> <p>Docs</p> <p> Environment variables: Basic rules \u2014 Invoke documentation.</p>"},{"location":"features/#coloured-output","title":"Coloured output","text":"<p>Use a pseudo-terminal by default (display colored output):</p> <pre><code># ~/.bashrc, ~/.zshrc or your favourite shell\nexport INVOKE_RUN_PTY=1\n</code></pre> <p>Docs</p> <p> runners \u2014 Invoke documentation.</p>"},{"location":"features/#short-aliases","title":"Short aliases","text":"<p>Add short aliases for the <code>invoke</code> command:</p> <pre><code># ~/.bashrc, ~/.zshrc or your favourite shell\nalias i='invoke'\nalias il='invoke --list'\nalias ih='invoke --help'\nalias ir='invoke --dry'\n</code></pre>"},{"location":"features/#auto-completion","title":"Auto-completion","text":"<p>Follow this quick copy/paste setup to configure auto-completion for Conjuring. Or read the links below for more details.</p> <p>To enable completion on terminals, add this to your <code>~/.bash_profile</code>:</p> <pre><code># ~/.bash_profile\nexport BASH_COMPLETION_USER_DIR=\"$HOME/.local/share/bash-completion\"\nif [[ -d \"$BASH_COMPLETION_USER_DIR/completions\" ]]; then\n    for COMPLETION in \"$BASH_COMPLETION_USER_DIR/completions/\"*; do\n        source \"$COMPLETION\"\n    done\nfi\n# https://github.com/tiangolo/typer installs completion files in this directory\nif [[ -d \"$HOME/.bash_completions/\" ]]; then\n    for COMPLETION in \"$HOME/.bash_completions/\"*; do\n        [[ -r \"$COMPLETION\" ]] &amp;&amp; source \"$COMPLETION\"\n    done\nfi\n</code></pre> <p>Then run these commands to install auto-completion for Invoke and Conjuring:</p> <pre><code># To get help, run `invoke` or `invoke --help`\ninvoke --print-completion-script=bash &gt; $BASH_COMPLETION_USER_DIR/completions/invoke.bash-completion\n\n# To get help, run `conjuring` or `conjuring --help`\nconjuring --install-completion bash\n</code></pre> <p>Then open a new terminal, type <code>invoke &lt;TAB&gt;</code> or <code>conjuring &lt;TAB&gt;</code>, and you will have auto-completion.</p> <p>You can even set up auto-completion for aliases (like <code>i &lt;TAB&gt;</code> for <code>invoke</code>) with the complete-alias project.</p> <p>Some links for more details:</p> <ul> <li>Shell tab completion \u2014 Invoke documentation</li> <li>scop/bash-completion: Programmable completion functions for bash</li> <li>cykerway/complete-alias: automagical shell alias completion;</li> </ul>"},{"location":"features/#creating-your-own-reusable-tasks","title":"Creating your own reusable tasks","text":""},{"location":"features/#add-your-own-custom-tasks-from-python-modules-or-packages-to-global-tasks","title":"Add your own custom tasks from Python modules or packages to global tasks","text":"<p>You can create your own Python modules or packages with Invoke tasks, and they can be added to the global scope and be available from any directory.</p> <ul> <li>On the init file, call <code>import_dirs()</code> with the path to your modules or packages;</li> <li>The import method detects if the directory is a Python package or not,   and imports it accordingly;</li> <li>The example uses <code>cast_all()</code>, but you can use any of the other <code>cast_*</code>   methods described above (opt-in   or opt-out).</li> </ul> <pre><code># ~/conjuring_init.py\nfrom conjuring import Spellbook\n\nnamespace = (\n    Spellbook()\n    .import_dirs(\n        \"~/path/to/your/src/my_package\",\n        \"~/path/to/a/some-directory-with-py-files\",\n    )\n    .cast_all()\n)\n</code></pre>"},{"location":"features/#display-your-custom-task-modules-conditionally","title":"Display your custom task modules conditionally","text":"<p>Some modules under the <code>spells</code> directory have a <code>should_display_tasks</code> boolean function to control whether the tasks are displayed or not.</p> <p>The <code>conjuring.visibility</code> module has boolean functions that can be reused by your modules and tasks.</p> <p>Example from the <code>conjuring.spells.git</code> module:</p> <pre><code># /path/to/your_task_module.py\nfrom conjuring.visibility import is_git_repo, ShouldDisplayTasks\n\nshould_display_tasks: ShouldDisplayTasks = is_git_repo\n</code></pre> <p>Other use cases:</p> <ul> <li>Poetry tasks: display only when   there is a <code>pyproject.toml</code> in the current dir;</li> <li>pre-commit tasks: display only   when there is a <code>.pre-commit-config.yaml</code> file in the current dir.</li> </ul>"},{"location":"features/#display-your-custom-individual-tasks-conditionally","title":"Display your custom individual tasks conditionally","text":"<p>A task can have its own visibility settings, even if the owner module is configured to not display tasks.</p> <pre><code># /path/to/another_task_module.py\nfrom invoke import task\nfrom conjuring.visibility import MagicTask\nfrom random import randint\n\n\n@task(klass=MagicTask)\ndef an_always_visible_task(c):\n    \"\"\"A MagicTask is always visible by default.\n\n    It will always be displayed in every directory,\n        regardless of the module ``should_display_tasks()`` function.\n    \"\"\"\n    pass\n\n\n@task(klass=MagicTask, should_display=lambda: bool(randint(0, 1)))\ndef a_conditionally_visible_task(c):\n    \"\"\"You can use any boolean function to determine visibility.\"\"\"\n    pass\n</code></pre> <p>Use case:</p> <ul> <li>you want to group tasks in a module, with a prefix and conditional display of tasks;</li> <li>you still want some individual tasks to always be displayed;</li> <li>or you want different conditions to display certain tasks.</li> </ul>"},{"location":"features/#merge-your-project-tasks-with-the-global-reusable-tasks","title":"Merge your project tasks with the global reusable tasks","text":"<p>Create local <code>conjuring*.py</code> files, and they will be merged with the <code>tasks.py</code> in your home dir. Your project dir can be anywhere under your home dir.</p> <p>Create two modules with Invoke tasks:</p> <pre><code># ~/path/to/project/conjuring_foo.py\nfrom invoke import task\n\n\n@task\ndef my_foo(c):\n    \"\"\"My foo task.\"\"\"\n    pass\n\n\n# ~/path/to/project/conjuring_bar.py\nfrom invoke import task\n\n\n@task\ndef my_bar(c):\n    \"\"\"My bar task.\"\"\"\n    pass\n</code></pre> <p>The task list in your project dir will show tasks from all files, including the home dir task list.</p> <pre><code>$ cd ~/path/to/project/\n$ invoke --list\nAvailable tasks:\n\n my-bar               My bar task.\n my-foo               My foo task.\n &lt;... the global Conjuring tasks will show up here...&gt;\n</code></pre>"},{"location":"features/#prefix-task-names-of-your-custom-module","title":"Prefix task names of your custom module","text":"<p>If the module defines this boolean constant with a value of <code>True</code>, then the name of the module will be added as a prefix to tasks.</p> <p>Example for the <code>conjuring.spells.pre_commit</code> module:</p> <pre><code>SHOULD_PREFIX = True\n</code></pre> <p>All the tasks of this module will have a <code>pre-commit.</code> prefix when you run <code>invoke --list</code>.</p>"},{"location":"related/","title":"Related projects","text":"<ul> <li>pyinvoke/invoke: Pythonic task management &amp; command execution.</li> <li>pyinvoke/invocations: Reusable Invoke tasks</li> <li>jhermann/rituals: Project automation task library for \u2018Invoke\u2019 tasks that are needed again and again.</li> </ul>"},{"location":"spells/","title":"Spells (API reference)","text":"<p>This is an API reference for the all the Invoke tasks and helper functions that are included in the Conjuring package.</p>"},{"location":"spells/#conjuring.spells.aws","title":"<code>conjuring.spells.aws</code>","text":"<p>AWS: ECR login.</p>"},{"location":"spells/#conjuring.spells.aws.clean_ecr_url","title":"<code>clean_ecr_url(c, url=None)</code>","text":"<p>Clean an AWS ECR URL.</p> Source code in <code>src/conjuring/spells/aws.py</code> <pre><code>def clean_ecr_url(c: Context, url: str | None = None) -&gt; str:\n    \"\"\"Clean an AWS ECR URL.\"\"\"\n    if not url:\n        account = fzf_aws_account(c)\n        region = fzf_aws_region(c)\n        return f\"{account}.dkr.ecr.{region}.amazonaws.com\"\n    return urlparse(url).netloc\n</code></pre>"},{"location":"spells/#conjuring.spells.aws.ecr_login","title":"<code>ecr_login(c, url='')</code>","text":"<p>Log in to AWS ECR.</p> <p>Using Amazon ECR with the AWS CLI - Amazon ECR</p> Source code in <code>src/conjuring/spells/aws.py</code> <pre><code>@task\ndef ecr_login(c: Context, url: str = \"\") -&gt; None:\n    \"\"\"Log in to AWS ECR.\n\n    [Using Amazon ECR with the AWS CLI - Amazon ECR](https://docs.aws.amazon.com/AmazonECR/latest/userguide/getting-started-cli.html#cli-authenticate-registry)\n    \"\"\"\n    profile = fzf_aws_profile(c)\n    url = clean_ecr_url(c, url)\n    run_command(\n        c,\n        \"aws ecr get-login-password --profile\",\n        profile,\n        \"| docker login --username AWS --password-stdin\",\n        url,\n    )\n</code></pre>"},{"location":"spells/#conjuring.spells.aws.fzf_aws_account","title":"<code>fzf_aws_account(c)</code>","text":"<p>Select an AWS account from the config file.</p> Source code in <code>src/conjuring/spells/aws.py</code> <pre><code>def fzf_aws_account(c: Context) -&gt; str:\n    \"\"\"Select an AWS account from the config file.\"\"\"\n    return run_with_fzf(c, f\"rg -o 'aws:iam::[^:]+' {AWS_CONFIG} | cut -d ':' -f 4 | sort -u\")\n</code></pre>"},{"location":"spells/#conjuring.spells.aws.fzf_aws_profile","title":"<code>fzf_aws_profile(c, partial_name=None)</code>","text":"<p>Select an AWS profile from a partial profile name using fzf.</p> Source code in <code>src/conjuring/spells/aws.py</code> <pre><code>def fzf_aws_profile(c: Context, partial_name: str | None = None) -&gt; str:\n    \"\"\"Select an AWS profile from a partial profile name using fzf.\"\"\"\n    if not partial_name and (aws_profile := os.environ.get(\"AWS_PROFILE\")) and aws_profile:\n        typer.echo(f\"Using env variable AWS_PROFILE (set to '{aws_profile}')\")\n        return aws_profile\n\n    return run_with_fzf(c, LIST_AWS_PROFILES_COMMAND, query=partial_name or \"\")\n</code></pre>"},{"location":"spells/#conjuring.spells.aws.fzf_aws_region","title":"<code>fzf_aws_region(c)</code>","text":"<p>Select an AWS region from the config file.</p> Source code in <code>src/conjuring/spells/aws.py</code> <pre><code>def fzf_aws_region(c: Context) -&gt; str:\n    \"\"\"Select an AWS region from the config file.\"\"\"\n    return run_with_fzf(c, f\"rg -o '^region.+' {AWS_CONFIG} | tr -d ' ' | cut -d'=' -f 2 | sort -u\")\n</code></pre>"},{"location":"spells/#conjuring.spells.aws.list_aws_profiles","title":"<code>list_aws_profiles(c)</code>","text":"<p>List AWS profiles from the config file.</p> Source code in <code>src/conjuring/spells/aws.py</code> <pre><code>def list_aws_profiles(c: Context) -&gt; list[str]:\n    \"\"\"List AWS profiles from the config file.\"\"\"\n    return run_lines(c, LIST_AWS_PROFILES_COMMAND)\n</code></pre>"},{"location":"spells/#conjuring.spells.aws.run_aws_vault","title":"<code>run_aws_vault(c, *pieces, profile=None)</code>","text":"<p>Run AWS vault commands in a subshell, or open a subshell if no commands were provided.</p> Source code in <code>src/conjuring/spells/aws.py</code> <pre><code>def run_aws_vault(c: Context, *pieces: str, profile: str | None = None) -&gt; Result:\n    \"\"\"Run AWS vault commands in a subshell, or open a subshell if no commands were provided.\"\"\"\n    return run_command(c, \"aws-vault exec\", fzf_aws_profile(c, profile), \"--\", *pieces, pty=False)\n</code></pre>"},{"location":"spells/#conjuring.spells.direnv","title":"<code>conjuring.spells.direnv</code>","text":"<p>direnv: init local dir.</p>"},{"location":"spells/#conjuring.spells.direnv.init","title":"<code>init(c, source_up=False, dotenv=False, all_=False)</code>","text":"<p>Configure direnv in the local dir.</p> Source code in <code>src/conjuring/spells/direnv.py</code> <pre><code>@task()\ndef init(c: Context, source_up: bool = False, dotenv: bool = False, all_: bool = False) -&gt; None:\n    \"\"\"Configure direnv in the local dir.\"\"\"\n    if all_:\n        source_up = dotenv = True\n    if not (source_up or dotenv or all_):\n        print_error(\"Choose one of the options: --source-up, --dotenv, --all\")\n        return\n\n    envrc = Path(ENVRC)\n    content = envrc.read_text() if envrc.exists() else \"\"\n\n    if source_up and SOURCE_UP_IF_EXISTS not in content:\n        content += SOURCE_UP_IF_EXISTS_TEMPLATE\n\n    if dotenv and DOTENV_IF_EXISTS not in content:\n        content += DOTENV_IF_EXISTS_TEMPLATE\n\n    if content:\n        envrc.write_text(content)\n        c.run(\"direnv allow\")\n\n    bat(c, \".env*\")\n</code></pre>"},{"location":"spells/#conjuring.spells.docker","title":"<code>conjuring.spells.docker</code>","text":"<p>Docker: remove containers and volumes.</p>"},{"location":"spells/#conjuring.spells.docker.rm_containers","title":"<code>rm_containers(c, container='', all_=False, exited=False)</code>","text":"<p>Remove Docker containers.</p> Source code in <code>src/conjuring/spells/docker.py</code> <pre><code>@task(\n    help={\n        \"container\": \"Container name to remove (regexp)\",\n        \"all_\": \"All containers\",\n        \"exited\": \"Exited containers\",\n    },\n)\ndef rm_containers(c: Context, container: str = \"\", all_: bool = False, exited: bool = False) -&gt; None:\n    \"\"\"Remove Docker containers.\"\"\"\n    cmd = []\n    if all_:\n        cmd = [\"docker ps -a\"]\n    elif exited:\n        cmd = [\"docker ps -a -f status=exited\"]\n    elif container:\n        cmd = [\"docker ps -a | grep -e\", container]\n    if not cmd:\n        print_error(\"Choose one argument. Run with --help to see available argument\")\n        return\n\n    run_command(c, *cmd, dry=False)\n    run_command(c, *cmd, \"| tail +2 | awk '{print $1}' | xargs docker rm -f\")\n    run_command(c, *cmd)\n</code></pre>"},{"location":"spells/#conjuring.spells.docker.rm_volumes","title":"<code>rm_volumes(c, dangling=False)</code>","text":"<p>Remove Docker volumes.</p> Source code in <code>src/conjuring/spells/docker.py</code> <pre><code>@task(help=({\"dangling\": \"Dangling volumes\"}))\ndef rm_volumes(c: Context, dangling: bool = False) -&gt; None:\n    \"\"\"Remove Docker volumes.\"\"\"\n    cmd = \"\"\n    if dangling:\n        cmd = 'docker volume ls -f \"dangling=true\"'\n    if not cmd:\n        print_error(\"Choose one argument. Run with --help to see available argument\")\n        return\n\n    run_command(c, cmd, dry=False)\n    run_command(c, f\"docker volume rm $({cmd} -q)\")\n    run_command(c, cmd)\n</code></pre>"},{"location":"spells/#conjuring.spells.duplicity","title":"<code>conjuring.spells.duplicity</code>","text":"<p>Backup and restore with Duplicity.</p>"},{"location":"spells/#conjuring.spells.duplicity.backup","title":"<code>backup(c)</code>","text":"<p>Backup files with Duplicity.</p> Source code in <code>src/conjuring/spells/duplicity.py</code> <pre><code>@task\ndef backup(c: Context) -&gt; None:\n    \"\"\"Backup files with Duplicity.\"\"\"\n    host = print_hostname(c)\n    backup_dir = f\"file://{BACKUP_DIR}/{host}/duplicity/\"\n    # To back up directly on OneDrive:\n    # backup_dir = f\"onedrive://Backup/{host}/duplicity/\"\n    typer.echo(f\"Backup dir: {backup_dir}\")\n\n    template_file = Path(\"~/dotfiles/backup-duplicity-template.cfg\").expanduser()\n    typer.echo(f\"Template file: {template_file}\")\n\n    template_contents = template_file.read_text()\n    duplicity_config = Template(template_contents).substitute({\"HOME\": Path.home()})\n\n    with NamedTemporaryFile(\"r+\", delete=False) as temp_file:\n        temp_file.write(duplicity_config)\n        temp_file.flush()\n        run_command(\n            c,\n            \"duplicity\",\n            f\"--name='{host}-backup'\",\n            \"-v info\",\n            f\"--include-filelist={temp_file.name}\",\n            \"--exclude='**' $HOME/\",\n            backup_dir,\n        )\n</code></pre>"},{"location":"spells/#conjuring.spells.duplicity.print_hostname","title":"<code>print_hostname(c)</code>","text":"<p>Print the hostname of the current machine.</p> Source code in <code>src/conjuring/spells/duplicity.py</code> <pre><code>def print_hostname(c: Context) -&gt; str:\n    \"\"\"Print the hostname of the current machine.\"\"\"\n    host = c.run(\"hostname | sed 's/.local//'\", dry=False).stdout.strip()\n    typer.echo(f\"Host: {host}\")\n    return host\n</code></pre>"},{"location":"spells/#conjuring.spells.duplicity.restore","title":"<code>restore(c)</code>","text":"<p>Restore files with Duplicity. You will be prompted to choose the source dir. Restore dir is ~/Downloads.</p> Source code in <code>src/conjuring/spells/duplicity.py</code> <pre><code>@task\ndef restore(c: Context) -&gt; None:\n    \"\"\"Restore files with Duplicity. You will be prompted to choose the source dir. Restore dir is ~/Downloads.\"\"\"\n    print_hostname(c)\n    chosen_dir = run_with_fzf(c, f\"fd -d 2 -t d duplicity {BACKUP_DIR}\")\n    if not chosen_dir:\n        return\n\n    source_computer = Path(chosen_dir).parent.name\n    c.run(f\"duplicity restore file://{chosen_dir} ~/Downloads/duplicity-restore/{source_computer}/\")\n</code></pre>"},{"location":"spells/#conjuring.spells.fork","title":"<code>conjuring.spells.fork</code>","text":"<p>GitHub forks: configure remote and sync.</p>"},{"location":"spells/#conjuring.spells.fork.remote","title":"<code>remote(c, username, remote_='upstream')</code>","text":"<p>Configure a remote for a fork.</p> Source code in <code>src/conjuring/spells/fork.py</code> <pre><code>@task(\n    help={\n        \"username\": \"The owner of the original repository. Required\",\n        \"remote\": \"The remote to sync with (default: upstream)\",\n    },\n)\ndef remote(c: Context, username: str, remote_: str = \"upstream\") -&gt; None:\n    \"\"\"[Configure a remote for a fork](https://docs.github.com/en/github/collaborating-with-issues-and-pull-requests/configuring-a-remote-for-a-fork).\"\"\"\n    if username.startswith(\"-\"):\n        msg = \"Arguments should be: username [--remote]\"\n        raise Exit(msg)\n    if not remote_:\n        remote_ = username\n\n    project = c.run(r\"git remote -v | rg origin | head -1 | rg -o '/(.+)\\.git' -r '$1'\", pty=False).stdout.strip()\n    c.run(f\"git remote add {remote_} https://github.com/{username}/{project}.git\", warn=True)\n    c.run(\"git remote -v\")\n</code></pre>"},{"location":"spells/#conjuring.spells.fork.sync","title":"<code>sync(c, remote_='upstream')</code>","text":"<p>Sync a fork.</p> Source code in <code>src/conjuring/spells/fork.py</code> <pre><code>@task(help={\"remote\": \"The remote to sync with (default: upstream)\"})\ndef sync(c: Context, remote_: str = \"upstream\") -&gt; None:\n    \"\"\"[Sync a fork](https://docs.github.com/en/github/collaborating-with-issues-and-pull-requests/syncing-a-fork).\"\"\"\n    c.run(f\"git fetch {remote_}\")\n    existing_branch = Git(c).checkout(\"master\", \"main\")\n    c.run(f\"git merge {remote_}/{existing_branch}\")\n    c.run(\"git push\")\n</code></pre>"},{"location":"spells/#conjuring.spells.generic","title":"<code>conjuring.spells.generic</code>","text":"<p>Generic spells: list to-do items in files.</p>"},{"location":"spells/#conjuring.spells.generic.Location","title":"<code>Location</code>  <code>dataclass</code>","text":"<p>Location of a to-do item in a file.</p> Source code in <code>src/conjuring/spells/generic.py</code> <pre><code>@dataclass\nclass Location:\n    \"\"\"Location of a to-do item in a file.\"\"\"\n\n    path: str\n    line: int | str\n    comment: str\n\n    def __post_init__(self) -&gt; None:\n        self.line = int(self.line)\n        self.comment = self.comment.strip()\n</code></pre>"},{"location":"spells/#conjuring.spells.generic.ToDoItem","title":"<code>ToDoItem</code>  <code>dataclass</code>","text":"<p>A to-do item.</p> Source code in <code>src/conjuring/spells/generic.py</code> <pre><code>@dataclass(frozen=True)\nclass ToDoItem:\n    \"\"\"A to-do item.\"\"\"\n\n    which: str\n    assignee: str\n    description: str\n\n    @property\n    def sort_key(self) -&gt; str:\n        \"\"\"Key to sort the instance.\n\n        String concatenation works.\n        Checking both fields separately with ``and`` conditions didn't work: sort order was not as expected\n        (meaning fix-me tasks first, then to-do tasks).\n        \"\"\"\n        return f\"{self.which.casefold()}-{self.assignee.casefold()}-{self.description.casefold()}\"\n\n    def __lt__(self, other: ToDoItem) -&gt; bool:\n        return self.sort_key &lt; other.sort_key\n</code></pre>"},{"location":"spells/#conjuring.spells.generic.ToDoItem.sort_key","title":"<code>sort_key</code>  <code>property</code>","text":"<p>Key to sort the instance.</p> <p>String concatenation works. Checking both fields separately with <code>and</code> conditions didn't work: sort order was not as expected (meaning fix-me tasks first, then to-do tasks).</p>"},{"location":"spells/#conjuring.spells.generic.todo","title":"<code>todo(c, cz=False, valid=True, invalid=True, short=False, priority='', markdown=False, dir_='')</code>","text":"<p>List to-dos and fix-mes in code. Optionally check if the description follows Conventional Commits (cz check).</p> Source code in <code>src/conjuring/spells/generic.py</code> <pre><code>@task(\n    help={\n        \"cz\": \"Run commitizen (cz check) to validate the description of the to-do item as a commit message\",\n        \"valid\": \"When using cz check, print valid to-do items\",\n        \"invalid\": \"When using cz check, print invalid to-do items\",\n        \"short\": \"Short format: only the description, without the lines of code where to-do items were found\",\n        \"priority\": \"Specify an assignee and show only higher priority tasks for them\"\n        f\" ({FIX_ME} or {TO_DO}(&lt;assignee&gt;)\",\n        \"markdown\": \"Print the output in Markdown format\",\n        \"dir\": \"Partial directory names to search for items. Use multiple times or a comma-separated list\",\n    },\n    iterable=[\"dir\"],\n)\ndef todo(  # noqa: C901,PLR0913,PLR0912\n    c: Context,\n    cz: bool = False,\n    valid: bool = True,\n    invalid: bool = True,\n    short: bool = False,\n    priority: str = \"\",\n    markdown: bool = False,\n    dir_: str = \"\",\n) -&gt; None:\n    \"\"\"List to-dos and fix-mes in code. Optionally check if the description follows Conventional Commits (cz check).\"\"\"\n    dir_names = []\n    if dir_:\n        for one_dir in always_iterable(dir_):\n            if \",\" in one_dir:\n                dir_names.extend(one_dir.split(\",\"))\n            else:\n                dir_names.append(one_dir)\n    all_todos: dict[ToDoItem, list[Location]] = _parse_all_todos(c, priority, dir_names)\n\n    if markdown:\n        _print_todos_as_markdown(all_todos, short)\n        return\n\n    for item, locations in sorted(all_todos.items()):  # type: ToDoItem, list[Location]\n        func = print_success\n        if cz:\n            result = run_command(c, \"cz check -m\", quote(item.description), hide=True, warn=True)\n            if result.ok:\n                if not valid:\n                    continue\n            else:\n                if not invalid:\n                    continue\n                func = print_error\n\n        assignee_str = f\"({item.assignee.upper()})\" if item.assignee else \"\"\n        func(f\"{item.which}{assignee_str}: {item.description}\")\n\n        if short:\n            continue\n        for loc in locations:  # type: Location\n            typer.echo(f\"   {loc.path}:{loc.line} {loc.comment}\")\n</code></pre>"},{"location":"spells/#conjuring.spells.git","title":"<code>conjuring.spells.git</code>","text":"<p>Git: update all, extract subtree, rewrite history, ...</p>"},{"location":"spells/#conjuring.spells.git.Git","title":"<code>Git</code>","text":"<p>Git helpers.</p> Source code in <code>src/conjuring/spells/git.py</code> <pre><code>class Git:\n    \"\"\"Git helpers.\"\"\"\n\n    # Use \"tail +2\" to remove the blank line at the top\n    SHOW_ALL_FILE_HISTORY = 'git log --pretty=\"format:\" --name-only | sort -u | tail +2'\n\n    def __init__(self, context: Context) -&gt; None:\n        self.context = context\n\n    def current_branch(self) -&gt; str:\n        \"\"\"Return the current branch name.\"\"\"\n        return run_stdout(self.context, \"git branch --show-current\")\n\n    def default_branch(self) -&gt; str:\n        \"\"\"Return the default branch name (master/main/develop/development).\"\"\"\n        return run_stdout(\n            self.context,\n            \"git branch -a | rg -o -e /master -e /develop.+ -e /main | sort -u | cut -b 2- | head -1\",\n        )\n\n    def checkout(self, *branches: str) -&gt; str:\n        \"\"\"Try checking out the specified branches in order.\"\"\"\n        for branch in branches:\n            try:\n                self.context.run(f\"git checkout {branch}\")\n            except UnexpectedExit:  # noqa: PERF203\n                pass\n            else:\n                return branch\n        return \"\"\n\n    @property\n    def github_username(self) -&gt; str:\n        \"\"\"The GitHub username configured in the global settings.\"\"\"\n        return global_config()[\"github\"][\"user\"]\n\n    def choose_local_branch(self, branch: str) -&gt; str:\n        \"\"\"Choose a local branch.\"\"\"\n        return run_with_fzf(self.context, \"git branch --list | rg -v develop | cut -b 3-\", query=branch)\n</code></pre>"},{"location":"spells/#conjuring.spells.git.Git.github_username","title":"<code>github_username</code>  <code>property</code>","text":"<p>The GitHub username configured in the global settings.</p>"},{"location":"spells/#conjuring.spells.git.Git.checkout","title":"<code>checkout(*branches)</code>","text":"<p>Try checking out the specified branches in order.</p> Source code in <code>src/conjuring/spells/git.py</code> <pre><code>def checkout(self, *branches: str) -&gt; str:\n    \"\"\"Try checking out the specified branches in order.\"\"\"\n    for branch in branches:\n        try:\n            self.context.run(f\"git checkout {branch}\")\n        except UnexpectedExit:  # noqa: PERF203\n            pass\n        else:\n            return branch\n    return \"\"\n</code></pre>"},{"location":"spells/#conjuring.spells.git.Git.choose_local_branch","title":"<code>choose_local_branch(branch)</code>","text":"<p>Choose a local branch.</p> Source code in <code>src/conjuring/spells/git.py</code> <pre><code>def choose_local_branch(self, branch: str) -&gt; str:\n    \"\"\"Choose a local branch.\"\"\"\n    return run_with_fzf(self.context, \"git branch --list | rg -v develop | cut -b 3-\", query=branch)\n</code></pre>"},{"location":"spells/#conjuring.spells.git.Git.current_branch","title":"<code>current_branch()</code>","text":"<p>Return the current branch name.</p> Source code in <code>src/conjuring/spells/git.py</code> <pre><code>def current_branch(self) -&gt; str:\n    \"\"\"Return the current branch name.\"\"\"\n    return run_stdout(self.context, \"git branch --show-current\")\n</code></pre>"},{"location":"spells/#conjuring.spells.git.Git.default_branch","title":"<code>default_branch()</code>","text":"<p>Return the default branch name (master/main/develop/development).</p> Source code in <code>src/conjuring/spells/git.py</code> <pre><code>def default_branch(self) -&gt; str:\n    \"\"\"Return the default branch name (master/main/develop/development).\"\"\"\n    return run_stdout(\n        self.context,\n        \"git branch -a | rg -o -e /master -e /develop.+ -e /main | sort -u | cut -b 2- | head -1\",\n    )\n</code></pre>"},{"location":"spells/#conjuring.spells.git.PrefixBranch","title":"<code>PrefixBranch</code>  <code>dataclass</code>","text":"<p>Tuple of prefix and branch name.</p> Source code in <code>src/conjuring/spells/git.py</code> <pre><code>@dataclass(frozen=True)\nclass PrefixBranch:\n    \"\"\"Tuple of prefix and branch name.\"\"\"\n\n    prefix: str\n    branch: str\n</code></pre>"},{"location":"spells/#conjuring.spells.git.body","title":"<code>body(c, prefix=False, original_order=False)</code>","text":"<p>Prepare a commit body to be used on pull requests and squashed commits.</p> Source code in <code>src/conjuring/spells/git.py</code> <pre><code>@task(\n    help={\n        \"prefix\": \"Keep the Conventional Commits prefix\",\n        \"original_order\": \"Don't sort bullets, keep them in original order\",\n    },\n)\ndef body(c: Context, prefix: bool = False, original_order: bool = False) -&gt; None:\n    \"\"\"Prepare a commit body to be used on pull requests and squashed commits.\"\"\"\n    default_branch = set_default_branch(c)\n    bullets = []\n    for line in run_lines(c, f\"git log {default_branch}..\", \"--format=%s%n%b\"):\n        clean = line.strip(\" -\")\n        if (\n            \"Merge branch\" in clean\n            or \"Merge remote-tracking branch\" in clean\n            or \"Revert \" in clean\n            or \"This reverts\" in clean\n            or not clean\n        ):\n            continue\n\n        # Remove Jira ticket with regex\n        clean = REGEX_JIRA.sub(\"\", clean).replace(\"()\", \"\").replace(\"[]\", \"\").strip(\" -\")\n\n        # Split on the Conventional Commit prefix\n        if not prefix and \":\" in clean:\n            clean = clean.split(\":\", 1)[1].strip()\n\n        bullets.append(f\"- {clean}\")\n\n    results = bullets if original_order else sorted(set(bullets))\n    typer.echo(\"\\n\".join(results))\n</code></pre>"},{"location":"spells/#conjuring.spells.git.changes_since_tag","title":"<code>changes_since_tag(c, tag='', files=False, verbose=False, by_author=False)</code>","text":"<p>Display changes (commits or files) since the last tag (or a chosen tag).</p> Source code in <code>src/conjuring/spells/git.py</code> <pre><code>@task(\n    help={\n        \"tag\": \"Name of the tag to compare to (default: last created tag)\",\n        \"files\": \"Display files instead of commits (default: false)\",\n        \"verbose\": \"Files: display changes/insertions/deletion.\"\n        \" Commits: display the full commit message, author... (default: False)\",\n        \"by_author\": \"Group commits by author. Doesn't work with --files or --verbose. (default: False)\",\n    },\n)\ndef changes_since_tag(\n    c: Context,\n    tag: str = \"\",\n    files: bool = False,\n    verbose: bool = False,\n    by_author: bool = False,\n) -&gt; None:\n    \"\"\"Display changes (commits or files) since the last tag (or a chosen tag).\"\"\"\n    if files:\n        which_tag = tag or run_stdout(c, \"git tag --list --sort -creatordate | head -1\", hide=False, dry=False)\n        default_branch = set_default_branch(c)\n        option = \"\" if verbose else \" --name-only\"\n        c.run(f\"git diff --stat {which_tag} origin/{default_branch}{option}\")\n    else:\n        which_tag = tag or \"$(git describe --tags --abbrev=0)\"\n        option = \" --format='%aN|%s' | sort -u\" if by_author else \"\" if verbose else \" --oneline\"\n        cmd = f\"git log {which_tag}..HEAD{option}\"\n        if by_author:\n            commits_by_author = defaultdict(list)\n            for line in run_lines(c, cmd):\n                author, commit = line.split(\"|\")\n                commits_by_author[author].append(commit)\n            for author, commits in commits_by_author.items():\n                print(f\"\\n{author}:\")  # noqa: T201\n                for commit in commits:\n                    print(f\"  {commit}\")  # noqa: T201\n        else:\n            c.run(cmd)\n</code></pre>"},{"location":"spells/#conjuring.spells.git.extract_subtree","title":"<code>extract_subtree(c, new_project_dir, reset=False)</code>","text":"<p>Extract files from subdirectories of the current Git repo to another repo, using git-filter-repo.</p> <p>Install https://github.com/newren/git-filter-repo with <code>pipx install git-filter-repo</code>.</p> Source code in <code>src/conjuring/spells/git.py</code> <pre><code>@task(\n    help={\n        \"new_project_dir\": \"Dir of the project to be created. The dir might exist or not\",\n        \"reset\": \"Remove the new dir and start over\",\n    },\n)\ndef extract_subtree(c: Context, new_project_dir: str, reset: bool = False) -&gt; None:\n    \"\"\"Extract files from subdirectories of the current Git repo to another repo, using git-filter-repo.\n\n    Install https://github.com/newren/git-filter-repo with `pipx install git-filter-repo`.\n    \"\"\"\n    new_project_path: Path = Path(new_project_dir).expanduser().resolve().absolute()\n    if reset:\n        c.run(f\"rm -rf {new_project_path}\")\n\n    if not new_project_path.exists():\n        origin_url = run_stdout(c, \"git remote get-url origin\")\n        c.run(f\"git clone {origin_url} {new_project_path}\")\n\n    files_and_dirs = set(run_lines(c, Git.SHOW_ALL_FILE_HISTORY, dry=False))\n    for line in sorted(files_and_dirs):\n        path = Path(line)\n        if os.path.sep in line:\n            files_and_dirs.add(str(path.parent) + os.path.sep)\n            continue\n\n    _, temp_filename = tempfile.mkstemp()\n    temp_file = Path(temp_filename)\n    try:\n        temp_file.write_text(os.linesep.join(sorted(files_and_dirs)))\n        chosen_files = set(\n            run_with_fzf(\n                c,\n                f\"cat {temp_filename}\",\n                dry=False,\n                header=\"Use TAB to choose the files you want to copy to the new project\",\n                multi=True,\n                preview=\"test -f {} &amp;&amp; head -20 {} || echo FILE NOT FOUND, IT EXISTS ONLY IN GIT HISTORY\",\n            ),\n        )\n    finally:\n        temp_file.unlink()\n\n    with c.cd(new_project_dir):\n        all_paths = [f\"--path '{line}'\" for line in sorted(chosen_files)]\n        c.run(f\"git-filter-repo {' '.join(all_paths)}\")\n        history(c, full=True)\n    print_error(\"Don't forget to switch to the new repo:\", f\"  cd {new_project_dir}\", join_nl=True)\n    print_success(\n        \"Next steps:\",\n        \"- Run 'invoke git.rewrite' to fix dates and authors\",\n        \"- Create a new empty repo on https://github.com/new without initializing it (no README/.gitignore/license)\",\n        \"- Follow the instructions to add a remote (from 'push an existing repository from the command line')\",\n        \"- Push files to the new repo with:\",\n        \"  git push -u origin master\",\n        join_nl=True,\n    )\n</code></pre>"},{"location":"spells/#conjuring.spells.git.global_config","title":"<code>global_config()</code>  <code>cached</code>","text":"<p>Global Git configuration.</p> Source code in <code>src/conjuring/spells/git.py</code> <pre><code>@lru_cache\ndef global_config() -&gt; ConfigParser:\n    \"\"\"Global Git configuration.\"\"\"\n    config = ConfigParser()\n    config.read(GLOBAL_GITCONFIG_PATH)\n    return config\n</code></pre>"},{"location":"spells/#conjuring.spells.git.history","title":"<code>history(c, full=False, files=False, author=False, dates=False)</code>","text":"<p>Grep the whole Git log and display information.</p> Source code in <code>src/conjuring/spells/git.py</code> <pre><code>@task(\n    help={\n        \"full\": \"Display all info: files, authors, dates\",\n        \"files\": \"Display all files in Git history, even the ones that were deleted and don't exist anymore\",\n        \"author\": \"Display authors\",\n        \"dates\": \"Display committer and author dates in different colors\",\n    },\n)\ndef history(c: Context, full: bool = False, files: bool = False, author: bool = False, dates: bool = False) -&gt; None:\n    \"\"\"Grep the whole Git log and display information.\"\"\"\n    option_chosen = False\n    if full:\n        option_chosen = True\n        files = author = dates = True\n    if files:\n        option_chosen = True\n        c.run(Git.SHOW_ALL_FILE_HISTORY)\n    if author:\n        option_chosen = True\n        c.run(\"git log --name-only | rg author | sort -u\")\n    if dates:\n        option_chosen = True\n        header = True\n        for line in run_lines(c, 'git log --format=\"%H|%cI|%aI|%GK|%s\"', hide=False):\n            if header:\n                print_success(\"Green = dates are equal\")\n                print_error(\"Red = dates are different\")\n                typer.echo(\n                    \"Commit                                   Committer Date            \"\n                    \"Author Date               GPG key          Subject\",\n                )\n                header = False\n\n            fields = line.split(\"|\")\n            committer_date = fields[1]\n            author_date = fields[2]\n            func = print_success if committer_date == author_date else print_error\n            func(*fields)\n    if not option_chosen:\n        msg = \"Choose at least one option: --full, --files, --author, --dates\"\n        raise Exit(msg, 1)\n</code></pre>"},{"location":"spells/#conjuring.spells.git.merge_default","title":"<code>merge_default(c, remote=False, update=True, push=True, rebase=False)</code>","text":"<p>Merge the default branch of the repo. Also set it with \"git config\", if not already set.</p> Source code in <code>src/conjuring/spells/git.py</code> <pre><code>@task(\n    help={\n        \"remote\": \"List remote branches (default: False)\",\n        \"update\": \"Update the repo before merging (default: True)\",\n        \"push\": \"Push the merge to the remote (default: True)\",\n        \"rebase\": \"Rebase the default branch before merging (default: False)\",\n    },\n)\ndef merge_default(\n    c: Context,\n    remote: bool = False,\n    update: bool = True,\n    push: bool = True,\n    rebase: bool = False,\n) -&gt; None:\n    \"\"\"Merge the default branch of the repo. Also set it with \"git config\", if not already set.\"\"\"\n    default_branch = set_default_branch(c, remote)\n\n    if update:\n        tidy_up(c)\n    which_verb = \"rebase\" if rebase else \"merge\"\n    run_command(c, f\"git {which_verb}\", f\"origin/{default_branch}\")\n    if push:\n        force_option = \"--force-with-lease\" if rebase else \"\"\n        run_command(c, \"git push\", force_option)\n</code></pre>"},{"location":"spells/#conjuring.spells.git.new_branch","title":"<code>new_branch(c, title)</code>","text":"<p>Create a new Git branch with a slugified title while keeping the Jira ticket in uppercase.</p> Source code in <code>src/conjuring/spells/git.py</code> <pre><code>@task\ndef new_branch(c: Context, title: str) -&gt; None:\n    \"\"\"Create a new Git branch with a slugified title while keeping the Jira ticket in uppercase.\"\"\"\n    match = REGEX_JIRA_TICKET_TITLE.match(title)\n\n    if match:\n        ticket: str = match.group(\"ticket\")\n        title_text: str = match.group(\"title\") or \"\"\n        slugified_title: str = slugify(title_text)\n        branch_name: str = f\"{ticket}-{slugified_title}\" if slugified_title else ticket\n    else:\n        branch_name = slugify(title)\n\n    typer.echo(f\"Creating branch: {branch_name}\")\n    c.run(f\"git checkout -b {branch_name}\")\n</code></pre>"},{"location":"spells/#conjuring.spells.git.rewrite","title":"<code>rewrite(c, commit='--root', gpg=True, author=True)</code>","text":"<p>Rewrite a range of commits, signing with GPG and setting the author.</p> <p>https://git-scm.com/docs/git-commit https://git-scm.com/docs/git-rebase</p> Source code in <code>src/conjuring/spells/git.py</code> <pre><code>@task(\n    help={\n        \"commit\": \"Base commit to be used for the range (default: --root)\",\n        \"gpg\": \"Sign the commit (default: True)\",\n        \"author\": \"Set the current author (taken from 'git config') on the commit range\",\n    },\n)\ndef rewrite(c: Context, commit: str = \"--root\", gpg: bool = True, author: bool = True) -&gt; None:\n    \"\"\"Rewrite a range of commits, signing with GPG and setting the author.\n\n    https://git-scm.com/docs/git-commit\n    https://git-scm.com/docs/git-rebase\n    \"\"\"\n    gpg_flag = \" --gpg-sign\" if gpg else \" --no-gpg-sign\"\n\n    author_flag = \"\"\n    if author:\n        name = run_stdout(c, \"git config user.name\", dry=False)\n        email = run_stdout(c, \"git config user.email\", dry=False)\n        author_flag = f' --author \"{name} &lt;{email}&gt;\"'\n\n    c.run(f'git log --format=\"%H %cI %aI %s\" {commit} &gt; $TMPDIR/rebase_sign_hashlist')\n    c.run(\n        \"git rebase --committer-date-is-author-date --exec 'GIT_COMMITTER_DATE=\"\n        '$(fgrep -m 1 \"$(git log -1 --format=\"%aI %s\" $GIT_COMMIT)\" $TMPDIR/rebase_sign_hashlist'\n        f' | cut -d\" \" -f3) git commit --amend --no-edit -n{author_flag}{gpg_flag}\\' -i {commit}',\n    )\n    history(c, dates=True)\n    typer.echo()\n    typer.echo(\"NOTE: If commits were modified during the rebase above, their committer date will be the current date\")\n    typer.echo(\"Rebase again with this command, without changing any commit, and all dates should be green\")\n</code></pre>"},{"location":"spells/#conjuring.spells.git.set_default_branch","title":"<code>set_default_branch(c, remote=False)</code>","text":"<p>Set the default branch config on the repo, if not configured yet.</p> Source code in <code>src/conjuring/spells/git.py</code> <pre><code>def set_default_branch(c: Context, remote: bool = False) -&gt; str:\n    \"\"\"Set the default branch config on the repo, if not configured yet.\"\"\"\n    cmd_read_default_branch = \"git config git-extras.default-branch\"\n    default_branch = run_stdout(c, cmd_read_default_branch, warn=True, dry=False)\n    if not default_branch:\n        default_branch = run_with_fzf(\n            c,\n            \"git branch --list\",\n            \"--all\" if remote else \"\",\n            \"| cut -b 3- | grep -v HEAD | sed -E 's#remotes/[^/]+/##g' | sort -u\",\n        )\n        run_command(c, cmd_read_default_branch, default_branch)\n        run_command(c, \"git config init.defaultBranch\", default_branch)\n        run_command(c, \"git config --list | rg default.*branch\")\n    return default_branch\n</code></pre>"},{"location":"spells/#conjuring.spells.git.switch_url_to","title":"<code>switch_url_to(c, remote='origin', https=False)</code>","text":"<p>Set an SSH or HTTPS URL for a remote.</p> Source code in <code>src/conjuring/spells/git.py</code> <pre><code>@task\ndef switch_url_to(c: Context, remote: str = \"origin\", https: bool = False) -&gt; None:\n    \"\"\"Set an SSH or HTTPS URL for a remote.\"\"\"\n    regex = r\"'git@(.+\\.com):(.+/.+)\\.git\\s'\" if https else r\"'/([^/]+\\.com)/([^/]+/.+)\\s\\('\"\n    replace = \"'$1/$2'\" if https else \"'$1:$2'\"\n\n    result = c.run(f\"git remote -v | rg {remote} | head -1 | rg -o {regex} -r {replace}\", warn=True, pty=False)\n    match = result.stdout.strip()\n    if not match:\n        typer.echo(f\"{Color.BOLD_RED.value}Match not found{Color.NONE.value}\")\n    else:\n        repo = f\"https://{match}\" if https else f\"git@{match}\"\n        if not repo.endswith(\".git\"):\n            repo += \".git\"\n        c.run(f\"git remote set-url {remote} {repo}\")\n\n    c.run(\"git remote -v\")\n</code></pre>"},{"location":"spells/#conjuring.spells.git.tidy_up","title":"<code>tidy_up(c)</code>","text":"<p>Prune remotes, update all branches of the repo, delete merged/squashed branches.</p> Source code in <code>src/conjuring/spells/git.py</code> <pre><code>@task\ndef tidy_up(c: Context) -&gt; None:\n    \"\"\"Prune remotes, update all branches of the repo, delete merged/squashed branches.\"\"\"\n    c.run(\"gitup .\")\n    c.run(\"git delete-merged-branches\")\n\n    # warn=True is needed; apparently, this command fails when there is no branch, and execution is stopped\n    c.run(\"git delete-squashed-branches\", warn=True)\n\n    for remote in run_lines(c, \"git remote\", dry=False):\n        c.run(f\"git remote prune {remote}\")\n</code></pre>"},{"location":"spells/#conjuring.spells.git.update_all","title":"<code>update_all(c, group='')</code>","text":"<p>Run gita super to update and clean branches.</p> Source code in <code>src/conjuring/spells/git.py</code> <pre><code>@task(klass=MagicTask)\ndef update_all(c: Context, group: str = \"\") -&gt; None:\n    \"\"\"Run gita super to update and clean branches.\"\"\"\n    parts = [\"gita\", \"super\"]\n    if group:\n        parts.append(group)\n    gita_super = \" \".join(parts)\n    c.run(f\"{gita_super} up &amp;&amp; {gita_super} delete-merged-branches\")\n</code></pre>"},{"location":"spells/#conjuring.spells.git.watch","title":"<code>watch(c)</code>","text":"<p>Watch a build on GitHub Actions, then open a pull request or repo after the build is over.</p> Source code in <code>src/conjuring/spells/git.py</code> <pre><code>@task()\ndef watch(c: Context) -&gt; None:\n    \"\"\"Watch a build on GitHub Actions, then open a pull request or repo after the build is over.\"\"\"\n    current_branch = Git(c).current_branch()\n    print_success(f\"Current branch = {current_branch}\")\n\n    c.run(\"gh run watch\", warn=True)\n    out = c.run(f\"gh pr view {current_branch} --web\", warn=True).stdout.strip()\n    if \"no pull requests found for branch\" in out:\n        c.run(\"gh repo view --web\")\n</code></pre>"},{"location":"spells/#conjuring.spells.jrnl","title":"<code>conjuring.spells.jrnl</code>","text":"<p>Query tags and entries with the jrnl note-taking tool.</p>"},{"location":"spells/#conjuring.spells.jrnl.edit_last","title":"<code>edit_last(c, journal='')</code>","text":"<p>Edit the last jrnl entry.</p> Source code in <code>src/conjuring/spells/jrnl.py</code> <pre><code>@task\ndef edit_last(c: Context, journal: str = \"\") -&gt; None:\n    \"\"\"Edit the last jrnl entry.\"\"\"\n    cmd = [\"jrnl\"]\n    if journal:\n        cmd.append(journal)\n    cmd.append(\"-1 --edit\")\n    c.run(\" \".join(cmd))\n</code></pre>"},{"location":"spells/#conjuring.spells.jrnl.query","title":"<code>query(c, n=0, contains='', edit=False, fancy=False, short=False, journal='')</code>","text":"<p>Query jrnl entries.</p> Source code in <code>src/conjuring/spells/jrnl.py</code> <pre><code>@task\ndef query(  # noqa: PLR0913\n    c: Context,\n    n: int = 0,\n    contains: str = \"\",\n    edit: bool = False,\n    fancy: bool = False,\n    short: bool = False,\n    journal: str = \"\",\n) -&gt; None:\n    \"\"\"Query jrnl entries.\"\"\"\n    format_ = \"pretty\"\n    if fancy:\n        format_ = \"fancy\"\n    elif short:\n        format_ = \"short\"\n\n    cmd = [\"jrnl\"]\n    if journal:\n        cmd.append(journal)\n    if n:\n        cmd.append(f\"-n {n}\")\n    cmd.append(f\"--format {format_}\")\n    if contains:\n        cmd.append(f\"-contains {contains}\")\n    if edit:\n        cmd.append(\"--edit\")\n    c.run(\" \".join(cmd))\n</code></pre>"},{"location":"spells/#conjuring.spells.jrnl.tags","title":"<code>tags(c, sort=False, rg='', journal='')</code>","text":"<p>Query jrnl tags.</p> Source code in <code>src/conjuring/spells/jrnl.py</code> <pre><code>@task\ndef tags(c: Context, sort: bool = False, rg: str = \"\", journal: str = \"\") -&gt; None:\n    \"\"\"Query jrnl tags.\"\"\"\n    cmd = [\"jrnl\"]\n    if journal:\n        cmd.append(journal)\n    cmd.append(\"--tags\")\n    if sort:\n        cmd.append(\"| sort -u\")\n    if rg:\n        cmd.append(f\"| rg {rg}\")\n    c.run(\" \".join(cmd))\n</code></pre>"},{"location":"spells/#conjuring.spells.k8s","title":"<code>conjuring.spells.k8s</code>","text":"<p>Kubernetes: get pods, show variables from config maps, validate score and more.</p>"},{"location":"spells/#conjuring.spells.k8s.Kubectl","title":"<code>Kubectl</code>  <code>dataclass</code>","text":"<p>Kubectl commands.</p> Source code in <code>src/conjuring/spells/k8s.py</code> <pre><code>@dataclass\nclass Kubectl:\n    \"\"\"Kubectl commands.\"\"\"\n\n    context: Context\n\n    def choose_apps(self, partial_name: str | None = None, *, multi: bool = False) -&gt; list[str]:\n        \"\"\"Select apps from Kubernetes deployments, using a partial app name and fzf.\n\n        Use the current dir as the app name if no partial app name is provided.\n        \"\"\"\n        if not partial_name:\n            return [Path.cwd().name]\n\n        return cast(\n            list[str],\n            run_with_fzf(\n                self.context,\n                \"\"\"kubectl get deployments.apps -o jsonpath='{range .items[*]}{.metadata.name}{\"\\\\n\"}{end}'\"\"\",\n                query=partial_name or \"\",\n                multi=multi,\n            ),\n        )\n\n    @staticmethod\n    def _app_selector(apps: list[str]) -&gt; str:\n        \"\"\"Return the app selector for one or more apps.\"\"\"\n        sorted_unique_apps = sorted(set(apps))\n        if len(sorted_unique_apps) == 1:\n            return f\"-l app={sorted_unique_apps[0]}\"\n        selector = f\" in ({', '.join(sorted_unique_apps)})\"\n        return f\"-l 'app{selector}'\"\n\n    def cmd_get(self, resource: str, apps: list[str]) -&gt; str:\n        \"\"\"Return the kubectl get command for one or more apps.\"\"\"\n        return f\"kubectl get {resource} {self._app_selector(apps)}\"\n\n    def run_get(self, resource: str, apps: list[str]) -&gt; Result:\n        \"\"\"Run the kubectl get command for one or more apps.\"\"\"\n        return run_command(self.context, self.cmd_get(resource, apps))\n</code></pre>"},{"location":"spells/#conjuring.spells.k8s.Kubectl.choose_apps","title":"<code>choose_apps(partial_name=None, *, multi=False)</code>","text":"<p>Select apps from Kubernetes deployments, using a partial app name and fzf.</p> <p>Use the current dir as the app name if no partial app name is provided.</p> Source code in <code>src/conjuring/spells/k8s.py</code> <pre><code>def choose_apps(self, partial_name: str | None = None, *, multi: bool = False) -&gt; list[str]:\n    \"\"\"Select apps from Kubernetes deployments, using a partial app name and fzf.\n\n    Use the current dir as the app name if no partial app name is provided.\n    \"\"\"\n    if not partial_name:\n        return [Path.cwd().name]\n\n    return cast(\n        list[str],\n        run_with_fzf(\n            self.context,\n            \"\"\"kubectl get deployments.apps -o jsonpath='{range .items[*]}{.metadata.name}{\"\\\\n\"}{end}'\"\"\",\n            query=partial_name or \"\",\n            multi=multi,\n        ),\n    )\n</code></pre>"},{"location":"spells/#conjuring.spells.k8s.Kubectl.cmd_get","title":"<code>cmd_get(resource, apps)</code>","text":"<p>Return the kubectl get command for one or more apps.</p> Source code in <code>src/conjuring/spells/k8s.py</code> <pre><code>def cmd_get(self, resource: str, apps: list[str]) -&gt; str:\n    \"\"\"Return the kubectl get command for one or more apps.\"\"\"\n    return f\"kubectl get {resource} {self._app_selector(apps)}\"\n</code></pre>"},{"location":"spells/#conjuring.spells.k8s.Kubectl.run_get","title":"<code>run_get(resource, apps)</code>","text":"<p>Run the kubectl get command for one or more apps.</p> Source code in <code>src/conjuring/spells/k8s.py</code> <pre><code>def run_get(self, resource: str, apps: list[str]) -&gt; Result:\n    \"\"\"Run the kubectl get command for one or more apps.\"\"\"\n    return run_command(self.context, self.cmd_get(resource, apps))\n</code></pre>"},{"location":"spells/#conjuring.spells.k8s.config_map","title":"<code>config_map(c, app, rg='')</code>","text":"<p>Show the config map for an app.</p> Source code in <code>src/conjuring/spells/k8s.py</code> <pre><code>@task(help={\"rg\": \"Filter results with rg\"})\ndef config_map(c: Context, app: str, rg: str = \"\") -&gt; None:\n    \"\"\"Show the config map for an app.\"\"\"\n    chosen_app = Kubectl(c).choose_apps(app)\n    run_command(\n        c,\n        f\"kubectl get deployment/{chosen_app} -o json\",\n        \"| jq -r .spec.template.spec.containers[].envFrom[].configMapRef.name\",\n        \"| rg -v null | xargs -I % kubectl get configmap/% -o json | jq -r .data\",\n        f\"| rg {rg}\" if rg else \"\",\n    )\n</code></pre>"},{"location":"spells/#conjuring.spells.k8s.exec_","title":"<code>exec_(c, app='')</code>","text":"<p>Exec into the first pod found for the chosen app.</p> Source code in <code>src/conjuring/spells/k8s.py</code> <pre><code>@task(name=\"exec\")\ndef exec_(c: Context, app: str = \"\") -&gt; None:\n    \"\"\"Exec into the first pod found for the chosen app.\"\"\"\n    kubectl = Kubectl(c)\n    chosen_app = kubectl.choose_apps(app)\n    chosen_pod = run_with_fzf(\n        c,\n        kubectl.cmd_get(\"pods\", chosen_app),\n        \"--no-headers\",\n        \"-o custom-columns=NAME:.metadata.name\",\n    )\n    run_command(c, f\"kubectl exec -it {chosen_pod} -- bash\")\n</code></pre>"},{"location":"spells/#conjuring.spells.k8s.pods","title":"<code>pods(c, app='', replica_set=False)</code>","text":"<p>Show the pods and replica sets for an app.</p> Source code in <code>src/conjuring/spells/k8s.py</code> <pre><code>@task(\n    help={\n        \"app\": \"Show the pods for an app; if not provided, the current directory name is used.\",\n        \"replica_set\": \"Show the replica sets for an app\",\n    },\n)\ndef pods(c: Context, app: str = \"\", replica_set: bool = False) -&gt; None:\n    \"\"\"Show the pods and replica sets for an app.\"\"\"\n    kubectl = Kubectl(c)\n    chosen_apps = kubectl.choose_apps(app, multi=True)\n    kubectl.run_get(\"pods\", chosen_apps)\n\n    if replica_set:\n        replica_set_names = run_lines(\n            c,\n            kubectl.cmd_get(\"pods\", chosen_apps),\n            \"\"\"-o jsonpath='{range .items[*]}{.metadata.ownerReferences[0].name}{\"\\\\n\"}{end}'\"\"\",\n            \"| sort -u\",\n        )\n        for name in replica_set_names:\n            run_command(c, f\"kubectl get replicaset {name}\")\n</code></pre>"},{"location":"spells/#conjuring.spells.k8s.validate_score","title":"<code>validate_score(c)</code>","text":"<p>Validate and score files that were changed from the master branch.</p> Source code in <code>src/conjuring/spells/k8s.py</code> <pre><code>@task()\ndef validate_score(c: Context) -&gt; None:\n    \"\"\"Validate and score files that were changed from the master branch.\"\"\"\n    # TODO: handle branches named \"main\"\n    # Continue even if there are errors\n    c.run(\"git diff master.. --name-only | xargs kubeval\", warn=True)\n    c.run(\"git diff master.. --name-only | xargs kubectl score\")\n</code></pre>"},{"location":"spells/#conjuring.spells.media","title":"<code>conjuring.spells.media</code>","text":"<p>Media files: remove empty dirs, clean up picture dirs, download YouTube videos, transcribe audio.</p>"},{"location":"spells/#conjuring.spells.media.CompareDirsAction","title":"<code>CompareDirsAction</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Actions to take when comparing two directories.</p> Source code in <code>src/conjuring/spells/media.py</code> <pre><code>class CompareDirsAction(Enum):\n    \"\"\"Actions to take when comparing two directories.\"\"\"\n\n    # keep-sorted start\n    DELETE_IDENTICAL = \"identical_deleted\"\n    DIFF_FAILED = \"diff_failed\"\n    DO_NOTHING = None\n    MOVE_IDENTICAL = \"identical\"\n    MOVE_NOT_FOUND = \"not_found\"\n</code></pre>"},{"location":"spells/#conjuring.spells.media.cleanup","title":"<code>cleanup(c, browse=False)</code>","text":"<p>Cleanup pictures.</p> Source code in <code>src/conjuring/spells/media.py</code> <pre><code>@task\ndef cleanup(c: Context, browse: bool = False) -&gt; None:\n    \"\"\"Cleanup pictures.\"\"\"\n    c.run(f\"fd -H -0 -tf -i {DOT_DS_STORE} | xargs -0 rm -v\")\n    c.run(f\"fd -H -0 -tf -i {DOT_NOMEDIA} | xargs -0 rm -v\")\n    c.run(\"find . -mindepth 1 -type d -empty -print -delete\")\n\n    # Unhide Picasa originals dir\n    for line in c.run(\"fd -H -t d .picasaoriginals\", pty=False).stdout.splitlines():\n        original_dir = Path(line)\n        c.run(f\"mv {original_dir} {original_dir.parent}/Picasa_Originals\")\n\n    # Keep the original dir as the main dir and rename parent dir to \"_Copy\"\n    for line in c.run(\"fd -t d originals\", pty=False).stdout.splitlines():\n        original_dir = Path(line)\n        c.run(f\"mv {original_dir} {original_dir.parent}_Temp\")\n        c.run(f\"mv {original_dir.parent} {original_dir.parent}_Copy\")\n        c.run(f\"mv {original_dir.parent}_Temp {original_dir.parent}\")\n\n    # Merge the copy dir with the main one\n    for line in run_command(c, \"fd -a -uu -t d --color never _copy\", str(ONEDRIVE_PICTURES_DIR)).stdout.splitlines():\n        copy_dir = Path(line)\n        original_dir = Path(line.replace(\"_Copy\", \"\"))\n        if original_dir.exists():\n            if browse:\n                c.run(f\"open '{original_dir}'\")\n            c.run(f\"merge-dirs '{original_dir}' '{copy_dir}'\")\n        else:\n            c.run(f\"mv '{copy_dir}' '{original_dir}'\")\n\n    # List dirs with _Copy files\n    copy_dirs = set()\n    for line in run_command(\n        c,\n        \"fd -H -t f --color never _copy\",\n        str(ONEDRIVE_PICTURES_DIR),\n        hide=True,\n    ).stdout.splitlines():\n        copy_dirs.add(Path(line).parent)\n\n    for dir_ in sorted(copy_dirs):\n        typer.echo(dir_)\n</code></pre>"},{"location":"spells/#conjuring.spells.media.compare_dirs","title":"<code>compare_dirs(c, from_dir, to_dir, count=MAX_COUNT, size=MAX_SIZE, delete=False, move=False, wildcard_search=False)</code>","text":"<p>Compare files in two directories. Stops when it reaches max count or size.</p> Source code in <code>src/conjuring/spells/media.py</code> <pre><code>@task(\n    help={\n        \"from_dir\": \"Source root directory to compare from\",\n        \"to_dir\": \"Destination root directory to compare to\",\n        \"count\": f\"Max number of files to compare. Default: {MAX_COUNT}\",\n        \"size\": f\"Max size of files to compare. Default: {naturalsize(MAX_SIZE)}\",\n        \"delete\": \"Delete identical files from the source dir\",\n        \"move\": \"Move identical files from the source dir to the output dir\",\n        \"wildcard_search\": \"If not found with the exact name,\"\n        \" search the destination dir using the file name with wildcards\",\n    },\n)\ndef compare_dirs(  # noqa: PLR0913\n    c: Context,\n    from_dir: str,\n    to_dir: str,\n    count: int = MAX_COUNT,\n    size: int = MAX_SIZE,\n    delete: bool = False,\n    move: bool = False,\n    wildcard_search: bool = False,\n) -&gt; None:\n    \"\"\"Compare files in two directories. Stops when it reaches max count or size.\"\"\"\n    if delete and move:\n        print_error(\"Choose either --delete or --move, not both\")\n        return\n    dry = not (delete or move) or c.config.run.dry\n\n    # Use a slug to compare multiple dirs at the same time\n    abs_from_dir = Path(from_dir).expanduser().absolute()\n    slug = str(abs_from_dir.relative_to(Path.home())).replace(os.sep, \"-\")\n    output_dir = DOWNLOADS_DIR / \"compare-dirs-output\" / slug\n\n    print_success(\"Output dir:\", str(output_dir), \"/ Stop file or dir:\", str(STOP_FILE_OR_DIR))\n\n    current_count = 0\n    current_size = 0\n\n    max_results = f\"--max-results {count}\" if count else \"\"\n    lines = run_lines(c, \"fd -t f -u\", max_results, \".\", str(abs_from_dir), \"| sort\", dry=False)\n\n    with tqdm(lines) as pbar:\n        for line in pbar:\n            if check_stop_file():\n                break\n\n            source_file: Path = Path(line).absolute()\n            if source_file.name == DOT_DS_STORE:\n                continue\n\n            current_count += 1\n            file_size = source_file.stat().st_size\n            current_size += file_size\n\n            partial_source_path = source_file.relative_to(abs_from_dir)\n            destination_file: Path = to_dir / partial_source_path\n\n            action, file_description = _determine_action(\n                c,\n                source_file,\n                to_dir,\n                destination_file,\n                delete,\n                move,\n                wildcard_search,\n            )\n\n            pbar.set_postfix(count=current_count, size=naturalsize(file_size), total_size=naturalsize(current_size))\n\n            # Check the file size after running the diff, so remote on-demand files are downloaded locally\n            if size and current_size &gt; size:\n                print_error(\n                    f\"Current size ({naturalsize(current_size)})\",\n                    f\"exceeded --size ({naturalsize(size)}), stopping\",\n                    dry=dry,\n                )\n                break\n\n            if action == CompareDirsAction.DO_NOTHING:\n                print_normal(file_description, dry=dry)\n                continue\n\n            _execute(\n                action,\n                source_file,\n                file_description,\n                output=output_dir / action.value / partial_source_path,\n                dry=dry,\n            )\n</code></pre>"},{"location":"spells/#conjuring.spells.media.empty_dirs","title":"<code>empty_dirs(c, dir_, delete=False, fd=True)</code>","text":"<p>Remove some hidden files first, then remove empty dirs.</p> <p>The ending slash is needed to search OneDrive, now that its behaviour changed in macOS Monterey.</p> Source code in <code>src/conjuring/spells/media.py</code> <pre><code>@task(\n    help={\n        \"dir\": \"Directory to clean up. Default: current dir\",\n        \"fd\": \"Use https://github.com/sharkdp/fd instead of 'find'\",\n        \"delete\": \"Delete the actual files (dotfiles are always deleted). Default: False\",\n    },\n    iterable=[\"dir_\"],\n)\ndef empty_dirs(c: Context, dir_: list[str | Path], delete: bool = False, fd: bool = True) -&gt; None:\n    \"\"\"Remove some hidden files first, then remove empty dirs.\n\n    The ending slash is needed to search OneDrive, now that its behaviour changed in macOS Monterey.\n    \"\"\"\n    if not dir_:\n        dir_ = [Path.cwd()]\n\n    dirs = list({str(Path(d).expanduser().absolute()) for d in dir_})\n    xargs = \"xargs -0 -n 1 rm -v\"\n    for hidden_file in [DOT_DS_STORE, DOT_NOMEDIA]:\n        if fd:\n            c.run(f\"fd -uu -0 -tf -i {hidden_file} {'/ '.join(dirs)}/ | {xargs}\")\n        else:\n            for one_dir in dirs:\n                c.run(f\"find {one_dir}/ -type f -iname {hidden_file} -print0 | {xargs}\")\n\n    f_option = \" \".join([f\"-f {d}/\" for d in dirs[:-1]])\n    delete_flag = \"-delete\" if delete else \"\"\n    run_command(c, \"find\", f_option, f\"{dirs[-1]}/ -mindepth 1 -type d -empty -print\", delete_flag)\n    if not delete:\n        print_warning(\"Run with --delete to actually delete the files\", dry=True)\n</code></pre>"},{"location":"spells/#conjuring.spells.media.invidious","title":"<code>invidious(c)</code>","text":"<p>Parse Invidious instances to be used in the Chrome plugin random instance pool.</p> <p>\"Invidious random instance pool (comma-separated)\" text field config from Privacy Redirect.</p> Source code in <code>src/conjuring/spells/media.py</code> <pre><code>@task\ndef invidious(c: Context) -&gt; None:\n    \"\"\"Parse Invidious instances to be used in the Chrome plugin random instance pool.\n\n    \"Invidious random instance pool (comma-separated)\" text field config\n    from [Privacy Redirect](https://chromewebstore.google.com/detail/privacy-redirect/pmcmeagblkinmogikoikkdjiligflglb).\n    \"\"\"\n    instances = run_lines(c, \"curl -s https://api.invidious.io/instances.json | jq -rs '.[].[][1].uri'\")\n    filtered = \",\".join([i for i in instances if not i.endswith(\".onion\") and not i.endswith(\".i2p\")])\n    run_command(c, f\"echo {filtered} | pbcopy\")\n</code></pre>"},{"location":"spells/#conjuring.spells.media.slideshow","title":"<code>slideshow(c, start_at='')</code>","text":"<p>Show pictures in the current dir with feh.</p> Source code in <code>src/conjuring/spells/media.py</code> <pre><code>@task\ndef slideshow(c: Context, start_at: str = \"\") -&gt; None:\n    \"\"\"Show pictures in the current dir with feh.\"\"\"\n    start_at_option = f\"--start-at {start_at}\" if start_at else \"\"\n    run_command(c, \"feh -r -. -g 1790x1070 -B black --caption-path .\", start_at_option)\n</code></pre>"},{"location":"spells/#conjuring.spells.media.sync_subtitle","title":"<code>sync_subtitle(c, episode)</code>","text":"<p>Sync subtitles for an episode or movie.</p> Source code in <code>src/conjuring/spells/media.py</code> <pre><code>@task\ndef sync_subtitle(c: Context, episode: str) -&gt; None:\n    \"\"\"Sync subtitles for an episode or movie.\"\"\"\n    fzf_cmd = \"fzf --height 40% --reverse --inline-info\"\n    video = c.run(f\"fd {episode} | {fzf_cmd} --header='Choose a video file'\", pty=False).stdout.strip()\n    subtitle = c.run(f\"fd {episode} | {fzf_cmd} --header='Choose a subtitle'\", pty=False).stdout.strip()\n    c.run(f'ffsubsync --max-offset-seconds 600 --overwrite-input \"{video}\" -i \"{subtitle}\"')\n</code></pre>"},{"location":"spells/#conjuring.spells.media.unzip_tree","title":"<code>unzip_tree(c, dir_, count=1, delete=False)</code>","text":"<p>Unzip .tar.gz files in a directory tree.</p> Source code in <code>src/conjuring/spells/media.py</code> <pre><code>@task(\n    help={\n        \"dir\": \"Root directory to unzip. Default: current dir\",\n        \"count\": \"Max number of files to unzip. Default: 1\",\n        \"delete\": \"Delete the .tar.gz file after unzipping with success. Default: False\",\n    },\n    iterable=[\"dir_\"],\n)\ndef unzip_tree(c: Context, dir_: list[str | Path], count: int = 1, delete: bool = False) -&gt; None:\n    \"\"\"Unzip .tar.gz files in a directory tree.\"\"\"\n    if not dir_:\n        dir_ = [Path.cwd()]\n\n    for one_dir in dir_:\n        for tar_gz_path in iter_path_with_progress(\n            c,\n            \"-t f .tar.gz\",\n            str(one_dir),\n            \"| sort --ignore-case\",\n            max_count=count,\n        ):\n            result = run_command(c, f\"gtar -xzf '{tar_gz_path}' -C '{tar_gz_path.parent}'\")\n            if result.ok and delete:\n                run_command(c, f\"rm '{tar_gz_path}'\")\n</code></pre>"},{"location":"spells/#conjuring.spells.media.whisper","title":"<code>whisper(c, dir_)</code>","text":"<p>Transcribe multiple audio file that haven't been transcribed yet, using whisper.</p> Source code in <code>src/conjuring/spells/media.py</code> <pre><code>@task(help={\"dir_\": \"Directory with audios to transcribe\"})\ndef whisper(c: Context, dir_: str | Path) -&gt; None:\n    \"\"\"Transcribe multiple audio file that haven't been transcribed yet, using whisper.\"\"\"\n    dir_ = Path(dir_).expanduser()\n    audios: list[Path] = []\n    for extension in AUDIO_EXTENSIONS:\n        audios.extend(dir_.glob(f\"*.{extension}\"))\n    for file in audios:\n        transcript_file = file.with_suffix(\".txt\")\n        if not transcript_file.exists():\n            c.run(f\"whisper --language pt -f txt '{file}' --output_dir '{file.parent}'\")\n            continue\n        c.run(f\"open '{transcript_file}'\")\n</code></pre>"},{"location":"spells/#conjuring.spells.media.youtube_dl","title":"<code>youtube_dl(c, url, min_height=360, download_archive_path='')</code>","text":"<p>Download video URLs, try different low-res formats until it finds one.</p> Source code in <code>src/conjuring/spells/media.py</code> <pre><code>@task\ndef youtube_dl(c: Context, url: str, min_height: int = 360, download_archive_path: str = \"\") -&gt; None:\n    \"\"\"Download video URLs, try different low-res formats until it finds one.\"\"\"\n    download_archive_path = download_archive_path or os.environ.get(\"YOUTUBE_DL_DOWNLOAD_ARCHIVE_PATH\", \"\")\n    archive_option = f\"--download-archive {download_archive_path!r}\" if download_archive_path else \"\"\n\n    all_heights = [h for h in [240, 360, 480, 0] if h &gt;= min_height or h == 0]\n    for height in all_heights:\n        # https://github.com/ytdl-org/youtube-dl#format-selection-examples\n        # Download best format available but no better than the chosen height\n        fmt = f\"-f 'bestvideo[height&lt;={height}]+bestaudio/best[height&lt;={height}]'\" if height else \"\"\n\n        result = run_command(\n            c,\n            \"yt-dlp --ignore-errors --restrict-filenames\",\n            # \"--get-title --get-id\",\n            # \"--get-thumbnail --get-description --get-duration --get-filename\",\n            # \"--get-format\",\n            archive_option,\n            fmt,\n            url,\n            warn=True,\n        )\n        if result.ok or \"Unsupported URL:\" in result.stdout:\n            break\n</code></pre>"},{"location":"spells/#conjuring.spells.media.zip_tree","title":"<code>zip_tree(c, dir_, count=1, depth=5, delete=False)</code>","text":"<p>Zip files in a directory tree, creating a .tar.gz file.</p> Source code in <code>src/conjuring/spells/media.py</code> <pre><code>@task(\n    help={\n        \"dir\": \"Root directory to zip. Default: current dir\",\n        \"count\": \"Max number of sub dirs to zip. Default: 1\",\n        \"delete\": \"Delete the directory after zipping with success. Default: False\",\n    },\n    iterable=[\"dir_\"],\n)\ndef zip_tree(c: Context, dir_: list[str | Path], count: int = 1, depth: int = 5, delete: bool = False) -&gt; None:\n    \"\"\"Zip files in a directory tree, creating a .tar.gz file.\"\"\"\n    if not dir_:\n        dir_ = [Path.cwd()]\n\n    for raw_dir in dir_:\n        path_dir = Path(raw_dir)\n        for path_to_zip in iter_path_with_progress(\n            c,\n            \"-t f --exclude '*.tar.gz' .\",\n            str(raw_dir),\n            \"--exec echo {//} | sort --unique --ignore-case\",\n            max_count=count,\n            reverse_depth=depth,\n        ):\n            if path_to_zip == path_dir:\n                continue\n\n            tar_gz_file = unique_file_name(path_to_zip.with_suffix(\".tar.gz\"))\n            with c.cd(path_to_zip.parent):\n                run_command(\n                    c,\n                    \"gtar\",\n                    \"--remove-files\" if delete else \"\",\n                    \"--exclude='*.tar.gz'\",\n                    f'-czf \"{tar_gz_file.name}\" -C . \"./{path_to_zip.name}\"',\n                    warn=True,\n                )\n</code></pre>"},{"location":"spells/#conjuring.spells.mkdocs","title":"<code>conjuring.spells.mkdocs</code>","text":"<p>MkDocs spells: install, build, deploy to GitHub, serve locally.</p>"},{"location":"spells/#conjuring.spells.mkdocs.browse","title":"<code>browse(c)</code>","text":"<p>Open the static HTML docs website on your browser.</p> Source code in <code>src/conjuring/spells/mkdocs.py</code> <pre><code>@task\ndef browse(c: Context) -&gt; None:\n    \"\"\"Open the static HTML docs website on your browser.\"\"\"\n    c.run(\"open http://127.0.0.1:8000/\")\n</code></pre>"},{"location":"spells/#conjuring.spells.mkdocs.build","title":"<code>build(c)</code>","text":"<p>Build docs.</p> Source code in <code>src/conjuring/spells/mkdocs.py</code> <pre><code>@task\ndef build(c: Context) -&gt; None:\n    \"\"\"Build docs.\"\"\"\n    c.run(\"mkdocs build --strict --verbose --site-dir site\")\n</code></pre>"},{"location":"spells/#conjuring.spells.mkdocs.deploy","title":"<code>deploy(c)</code>","text":"<p>Deploy docs to GitHub pages.</p> Source code in <code>src/conjuring/spells/mkdocs.py</code> <pre><code>@task(pre=[build])\ndef deploy(c: Context) -&gt; None:\n    \"\"\"Deploy docs to GitHub pages.\"\"\"\n    c.run(\"mkdocs gh-deploy\")\n</code></pre>"},{"location":"spells/#conjuring.spells.mkdocs.install","title":"<code>install(c, force=False)</code>","text":"<p>Install MkDocs globally with the Material plugin. Upgrade if it already exists.</p> Source code in <code>src/conjuring/spells/mkdocs.py</code> <pre><code>@task(help={\"force\": \"Force re-installation of MkDocs.\"})\ndef install(c: Context, force: bool = False) -&gt; None:\n    \"\"\"Install MkDocs globally with the Material plugin. Upgrade if it already exists.\"\"\"\n    upgrade = \" || pipx upgrade mkdocs\" if force else \"\"\n    c.run(f\"pipx install mkdocs{upgrade}\", warn=True)\n    for extension in EXTENSIONS:\n        c.run(f\"pipx inject mkdocs {extension}\")\n\n    # Inject the local project into the global MkDocs installation.\n    if has_pyproject_toml():\n        c.run(\"pipx inject mkdocs -e .\")\n</code></pre>"},{"location":"spells/#conjuring.spells.mkdocs.serve","title":"<code>serve(c)</code>","text":"<p>Start the live-reloading server to test the docs locally.</p> Source code in <code>src/conjuring/spells/mkdocs.py</code> <pre><code>@task(pre=[build])\ndef serve(c: Context) -&gt; None:\n    \"\"\"Start the live-reloading server to test the docs locally.\"\"\"\n    c.run(\"mkdocs serve\")\n</code></pre>"},{"location":"spells/#conjuring.spells.mkdocs.uninstall","title":"<code>uninstall(c)</code>","text":"<p>Uninstall MkDocs globally.</p> Source code in <code>src/conjuring/spells/mkdocs.py</code> <pre><code>@task\ndef uninstall(c: Context) -&gt; None:\n    \"\"\"Uninstall MkDocs globally.\"\"\"\n    c.run(\"pipx uninstall mkdocs\")\n</code></pre>"},{"location":"spells/#conjuring.spells.mr","title":"<code>conjuring.spells.mr</code>","text":"<p>myrepos repository management tool: grep text in repos.</p>"},{"location":"spells/#conjuring.spells.mr.MyRepos","title":"<code>MyRepos</code>  <code>dataclass</code>","text":"<p>Find and interact with myrepos config files.</p> Source code in <code>src/conjuring/spells/mr.py</code> <pre><code>@dataclass\nclass MyRepos:\n    \"\"\"Find and interact with myrepos config files.\"\"\"\n\n    context: Context\n\n    def find_configs(self, partial_name: str, echo: bool = False) -&gt; list[Path]:\n        \"\"\"Find config files in the current dir or dirs above.\"\"\"\n        lower_partial_name = partial_name.lower()\n        glob_pattern = MRCONFIG_FILE if not lower_partial_name else f\"{MRCONFIG_FILE}*{lower_partial_name}*\"\n        config_dir = self._find_dir_with_mrconfigs(glob_pattern)\n        if not config_dir:\n            msg = f\"No {MRCONFIG_FILE}* file was found in {Path.cwd()} or its parents\"\n            raise FileNotFoundError(msg)\n\n        if not lower_partial_name:\n            return [config_dir / MRCONFIG_FILE]\n\n        with self.context.cd(str(config_dir)):\n            chosen = run_with_fzf(\n                self.context,\n                \"ls -1\",\n                f\"{MRCONFIG_FILE}*\",\n                query=lower_partial_name,\n                multi=True,\n                echo=echo,\n                hide=not echo,\n            )\n        return sorted({config_dir / c for c in chosen})\n\n    @staticmethod\n    def _find_dir_with_mrconfigs(glob_pattern: str) -&gt; Path | None:\n        for dir_ in chain([Path.cwd()], Path.cwd().parents):\n            for _ in dir_.glob(glob_pattern):\n                # Exit loop on the first file found; fzf will handle the rest\n                return dir_\n        return None\n</code></pre>"},{"location":"spells/#conjuring.spells.mr.MyRepos.find_configs","title":"<code>find_configs(partial_name, echo=False)</code>","text":"<p>Find config files in the current dir or dirs above.</p> Source code in <code>src/conjuring/spells/mr.py</code> <pre><code>def find_configs(self, partial_name: str, echo: bool = False) -&gt; list[Path]:\n    \"\"\"Find config files in the current dir or dirs above.\"\"\"\n    lower_partial_name = partial_name.lower()\n    glob_pattern = MRCONFIG_FILE if not lower_partial_name else f\"{MRCONFIG_FILE}*{lower_partial_name}*\"\n    config_dir = self._find_dir_with_mrconfigs(glob_pattern)\n    if not config_dir:\n        msg = f\"No {MRCONFIG_FILE}* file was found in {Path.cwd()} or its parents\"\n        raise FileNotFoundError(msg)\n\n    if not lower_partial_name:\n        return [config_dir / MRCONFIG_FILE]\n\n    with self.context.cd(str(config_dir)):\n        chosen = run_with_fzf(\n            self.context,\n            \"ls -1\",\n            f\"{MRCONFIG_FILE}*\",\n            query=lower_partial_name,\n            multi=True,\n            echo=echo,\n            hide=not echo,\n        )\n    return sorted({config_dir / c for c in chosen})\n</code></pre>"},{"location":"spells/#conjuring.spells.mr.grep","title":"<code>grep(c, search_text, config='', echo=False)</code>","text":"<p>Grep mr repositories with a search text and print the directories in which the text was found.</p> <p>Needs mr to be preconfigured with files starting with the \".mrconfig\" prefix.</p> Source code in <code>src/conjuring/spells/mr.py</code> <pre><code>@task(\n    help={\n        \"config\": f\"Specific config file to use. Use fzf if multiple are found. Default: {MRCONFIG_FILE}\",\n        \"echo\": \"Echo the commands being executed, for debugging purposes. Default: False\",\n    },\n)\ndef grep(c: Context, search_text: str, config: str = \"\", echo: bool = False) -&gt; None:\n    \"\"\"Grep mr repositories with a search text and print the directories in which the text was found.\n\n    Needs mr to be preconfigured with files starting with the \".mrconfig\" prefix.\n    \"\"\"\n    for chosen in MyRepos(c).find_configs(config, echo=echo):\n        # For some reason, using run_command() prints a \"\\r\" char at the end of each line;\n        # the solution is to get output as a string and use print().\n        output_without_linefeed = run_stdout(\n            c,\n            \"mr -c\",\n            str(chosen),\n            \"-m grep\",\n            search_text,\n            \"| rg --color=never 'mr grep: (.+)$' --replace '$1'\",\n            echo=echo,\n        )\n        typer.echo(output_without_linefeed)\n</code></pre>"},{"location":"spells/#conjuring.spells.onedrive","title":"<code>conjuring.spells.onedrive</code>","text":"<p>OneDrive: list files with conflicts.</p>"},{"location":"spells/#conjuring.spells.onedrive.conflicts","title":"<code>conflicts(c, dir_)</code>","text":"<p>List files with conflicts.</p> Source code in <code>src/conjuring/spells/onedrive.py</code> <pre><code>@task(\n    help={\"dir\": \"Directory; can be used multiple times. Default: current dir\"},\n    iterable=[\"dir_\"],\n)\ndef conflicts(c: Context, dir_: list[str | Path]) -&gt; None:\n    \"\"\"List files with conflicts.\"\"\"\n    if not dir_:\n        dir_ = [Path.cwd()]\n\n    hostname = run_stdout(c, \"hostname -s\").strip()\n    suffix = f\"-{hostname}\"\n    for one_dir in list({str(Path(d).expanduser().absolute()) for d in dir_}):\n        for line in run_lines(c, f\"fd -t f {hostname} {one_dir} | sort\"):\n            duplicated = Path(line)\n            original_name = duplicated.stem[: -len(suffix)]\n            original = duplicated.with_stem(original_name)\n            typer.echo(run_stdout(c, f\"diff {duplicated} {original}\", warn=True).strip())\n</code></pre>"},{"location":"spells/#conjuring.spells.onedrive.force_downloads","title":"<code>force_downloads(c, dir_)</code>","text":"<p>Force downloads of remote OneDrive files by reading them with a dummy \"diff\".</p> Source code in <code>src/conjuring/spells/onedrive.py</code> <pre><code>@task(\n    help={\"dir\": \"Directory; can be used multiple times. Default: current dir\"},\n    iterable=[\"dir_\"],\n)\ndef force_downloads(c: Context, dir_: list[str | Path]) -&gt; None:\n    \"\"\"Force downloads of remote OneDrive files by reading them with a dummy \"diff\".\"\"\"\n    if not dir_:\n        dir_ = [Path.cwd()]\n    temp_file = Path().home() / \"delete-me\"\n    temp_file.touch(exist_ok=True)\n    for one_dir in dir_:\n        c.run(f\"fd -t f -0 . {one_dir} | sort -z | xargs -0 -n 1 diff {temp_file}\")\n    temp_file.unlink()\n</code></pre>"},{"location":"spells/#conjuring.spells.paperless","title":"<code>conjuring.spells.paperless</code>","text":"<p>Paperless: maintenance, renamer, sanity, delete duplicates.</p>"},{"location":"spells/#conjuring.spells.paperless.Document","title":"<code>Document</code>  <code>dataclass</code>","text":"<p>A paperless document.</p> Source code in <code>src/conjuring/spells/paperless.py</code> <pre><code>@dataclass\nclass Document:\n    \"\"\"A paperless document.\"\"\"\n\n    document_id: int\n    title: str\n    errors: list = field(default_factory=list, init=False)\n</code></pre>"},{"location":"spells/#conjuring.spells.paperless.OrphanFile","title":"<code>OrphanFile</code>  <code>dataclass</code>","text":"<p>A paperless orphan file.</p> Source code in <code>src/conjuring/spells/paperless.py</code> <pre><code>@dataclass\nclass OrphanFile:\n    \"\"\"A paperless orphan file.\"\"\"\n\n    source: Path\n    destination: Path\n\n    def __lt__(self, other: OrphanFile) -&gt; bool:\n        return self.source &lt; other.source\n</code></pre>"},{"location":"spells/#conjuring.spells.paperless.delete_failed_duplicates","title":"<code>delete_failed_duplicates(c, max_delete=100)</code>","text":"<p>Delete records marked as duplicate but that cannot be downloaded. So the PDF files can be reimported.</p> Source code in <code>src/conjuring/spells/paperless.py</code> <pre><code>@task\ndef delete_failed_duplicates(c: Context, max_delete: int = 100) -&gt; None:\n    \"\"\"Delete records marked as duplicate but that cannot be downloaded. So the PDF files can be reimported.\"\"\"\n    session = requests.Session()\n    session.headers.update({\"authorization\": f\"token {paperless_token()}\"})\n\n    delete_count = 0\n    req_tasks = session.get(f\"{paperless_url()}/api/tasks/?format=json\")\n    for obj in req_tasks.json():\n        if obj[\"status\"] != \"FAILURE\":\n            continue\n\n        raw_line = obj[\"result\"]\n        if DUPLICATE_OF not in raw_line:\n            print_error(f\"Unknown error: {raw_line}\")\n            continue\n\n        clean_line = raw_line.replace(\" Not consuming \", \"\").replace(DUPLICATE_OF, \"\")\n        first, second, duplicate_with_id = clean_line.split(\":\", maxsplit=2)\n        if first != second:\n            print_error(f\"Files are different: {first=} / {second=}\")\n        match = REGEX_TITLE_WITH_ID.match(duplicate_with_id)\n        if not match:\n            print_error(f\"Line doesn't match regex {duplicate_with_id=}\", clean_line)\n            continue\n\n        data = match.groupdict()\n        document_id = data[\"id\"]\n\n        api_document_url = f\"{paperless_url()}/api/documents/{document_id}/\"\n        document_url = f\"{paperless_url()}/documents/{document_id}\"\n        url = f\"{api_document_url}download/\"\n        req_download = session.head(url)\n        if req_download.status_code != HTTPStatus.NOT_FOUND:\n            print_success(document_url, f\"Document exists {req_download.status_code=}\", clean_line)\n            continue\n\n        req_document = session.head(api_document_url)\n        if req_document.status_code == HTTPStatus.NOT_FOUND:\n            print_warning(document_url, \"Document already deleted before\", clean_line)\n            continue\n\n        req_delete = session.delete(api_document_url)\n        if req_delete.status_code == HTTPStatus.NO_CONTENT:\n            print_success(document_url, f\"Document deleted #{delete_count}\", clean_line)\n            delete_count += 1\n            if delete_count &gt;= max_delete:\n                raise SystemExit\n            continue\n\n        print_error(document_url, clean_line, f\"Something wrong: {req_delete.status_code=}\")\n        c.run(f\"open {document_url}\")\n</code></pre>"},{"location":"spells/#conjuring.spells.paperless.maintenance","title":"<code>maintenance(c, reindex=True, optimize=True, thumbnails=True)</code>","text":"<p>Reindex all docs and optionally optimize them.</p> <p>https://docs.paperless-ngx.com/administration/#index https://docs.paperless-ngx.com/administration/#thumbnails</p> Source code in <code>src/conjuring/spells/paperless.py</code> <pre><code>@task\ndef maintenance(c: Context, reindex: bool = True, optimize: bool = True, thumbnails: bool = True) -&gt; None:\n    \"\"\"Reindex all docs and optionally optimize them.\n\n    https://docs.paperless-ngx.com/administration/#index\n    https://docs.paperless-ngx.com/administration/#thumbnails\n    \"\"\"\n    if reindex:\n        c.run(f\"{paperless_cmd()} document_index reindex\")\n    if optimize:\n        c.run(f\"{paperless_cmd()} document_index optimize\")\n    if thumbnails:\n        c.run(f\"{paperless_cmd()} document_thumbnails\")\n</code></pre>"},{"location":"spells/#conjuring.spells.paperless.paperless_cmd","title":"<code>paperless_cmd()</code>","text":"<p>Command to run Paperless with Docker.</p> Source code in <code>src/conjuring/spells/paperless.py</code> <pre><code>def paperless_cmd() -&gt; str:\n    \"\"\"Command to run Paperless with Docker.\"\"\"\n    yaml_file = lazy_env_variable(\"PAPERLESS_COMPOSE_YAML\", \"path to the Paperless Docker compose YAML file\")\n    return f\"docker compose -f {yaml_file} exec webserver\"\n</code></pre>"},{"location":"spells/#conjuring.spells.paperless.paperless_documents_dir","title":"<code>paperless_documents_dir()</code>","text":"<p>Directory where Paperless stores documents.</p> Source code in <code>src/conjuring/spells/paperless.py</code> <pre><code>def paperless_documents_dir() -&gt; Path:\n    \"\"\"Directory where Paperless stores documents.\"\"\"\n    documents_dir = lazy_env_variable(\"PAPERLESS_MEDIA_DOCUMENTS_DIR\", \"directory where Paperless stores documents\")\n    return Path(documents_dir).expanduser()\n</code></pre>"},{"location":"spells/#conjuring.spells.paperless.paperless_token","title":"<code>paperless_token()</code>","text":"<p>Auth token to access Paperless API.</p> Source code in <code>src/conjuring/spells/paperless.py</code> <pre><code>def paperless_token() -&gt; str:\n    \"\"\"Auth token to access Paperless API.\"\"\"\n    return lazy_env_variable(\"PAPERLESS_TOKEN\", \"auth token to access Paperless API\")\n</code></pre>"},{"location":"spells/#conjuring.spells.paperless.paperless_url","title":"<code>paperless_url()</code>","text":"<p>URL where Paperless is running.</p> Source code in <code>src/conjuring/spells/paperless.py</code> <pre><code>def paperless_url() -&gt; str:\n    \"\"\"URL where Paperless is running.\"\"\"\n    return lazy_env_variable(\"PAPERLESS_URL\", \"URL where Paperless is running\")\n</code></pre>"},{"location":"spells/#conjuring.spells.paperless.rename","title":"<code>rename(c)</code>","text":"<p>Rename files.</p> <p>https://docs.paperless-ngx.com/administration/#renamer</p> Source code in <code>src/conjuring/spells/paperless.py</code> <pre><code>@task\ndef rename(c: Context) -&gt; None:\n    \"\"\"Rename files.\n\n    https://docs.paperless-ngx.com/administration/#renamer\n    \"\"\"\n    c.run(f\"{paperless_cmd()} document_renamer\")\n</code></pre>"},{"location":"spells/#conjuring.spells.paperless.sanity","title":"<code>sanity(c, hide=True, orphans=False, thumbnails=False, documents=False, unknown=True, together=False, fix=False, move=False)</code>","text":"<p>Sanity checker. Optionally fix orphan files (copies or movies them to the download dir).</p> <p>https://docs.paperless-ngx.com/administration/#sanity-checker</p> Source code in <code>src/conjuring/spells/paperless.py</code> <pre><code>@task(\n    help={\n        \"hide\": \"Hide progress bar of sanity command\",\n        \"orphans\": \"Show orphan files\",\n        \"thumbnails\": \"Show thumbnail files\",\n        \"documents\": \"Show documents with issues\",\n        \"unknown\": \"Show unknown lines from the log\",\n        \"together\": f\"Keep {ORPHAN_ORIGINALS} and {ORPHAN_ARCHIVE} in the same output directory\",\n        \"fix\": \"Fix broken files by copying them to the downloads dir\",\n        \"move\": \"Move files instead of copying\",\n    },\n)\ndef sanity(  # noqa: PLR0913\n    c: Context,\n    hide: bool = True,\n    orphans: bool = False,\n    thumbnails: bool = False,\n    documents: bool = False,\n    unknown: bool = True,\n    together: bool = False,\n    fix: bool = False,\n    move: bool = False,\n) -&gt; None:\n    \"\"\"Sanity checker. Optionally fix orphan files (copies or movies them to the download dir).\n\n    https://docs.paperless-ngx.com/administration/#sanity-checker\n    \"\"\"\n    # Fail fast if the env var is not set\n    documents_dir = paperless_documents_dir() if fix else None\n    if documents_dir and not documents_dir.exists():\n        msg = f\"Documents directory doesn't exist: {documents_dir}\"\n        raise RuntimeError(msg)\n\n    # TODO: fix(paperless): implement dry-run mode with dry=False and actually avoid files being copied/moved\n    lines = run_lines(c, paperless_cmd(), \"document_sanity_checker\", hide=hide, warn=True, pty=True)\n\n    progress_bar: list[str] = []\n    original_or_archive_files: dict[str, list[OrphanFile]] = defaultdict(list)\n    matched_files: list[OrphanFile] = []\n    unmatched_files: list[OrphanFile] = []\n    orphan_files: list[str] = []\n    thumbnail_files: list[str] = []\n    current_document: Document | None = None\n    documents_with_issues: list[Document] = []\n    unknown_lines = []\n    for line in lines:\n        if \"it/s]\" in line:\n            progress_bar.append(line)\n            continue\n\n        if (msg := \"Orphaned file in media dir: \") in line:\n            partial_path = Path(line.split(msg)[1].replace(USR_SRC_DOCUMENTS, \"\"))\n            _process_orphans(partial_path, documents_dir, original_or_archive_files, orphan_files, thumbnail_files)\n            continue\n\n        if (msg := \"Detected following issue(s) with document #\") in line:\n            # Append the previous document\n            if current_document:\n                documents_with_issues.append(current_document)\n\n            document_id, title = line.split(msg)[1].split(\", titled \")\n            current_document = Document(int(document_id), title)\n            continue\n\n        if current_document:\n            _, error = line.split(\"[paperless.sanity_checker] \")\n            current_document.errors.append(error)\n            continue\n\n        unknown_lines.append(line)\n\n    _split_matched_unmatched(original_or_archive_files, matched_files, unmatched_files, together)\n\n    _handle_items(fix, move, orphans, \"Matched files\", matched_files)\n    _handle_items(fix, move, orphans, \"Unmatched files\", unmatched_files)\n    _handle_items(False, move, orphans, \"Orphan files\", orphan_files)\n    # TODO: feat(paperless): move thumbnail files to downloads dir\n    _handle_items(fix, move, thumbnails, \"Thumbnail files\", thumbnail_files)\n    _handle_items(False, move, documents, \"Documents with issues\", documents_with_issues)\n    _handle_items(False, move, unknown, \"Unknown lines\", unknown_lines)\n</code></pre>"},{"location":"spells/#conjuring.spells.pre_commit","title":"<code>conjuring.spells.pre_commit</code>","text":"<p>pre-commit: install, uninstall, run/autoupdate selected hooks.</p>"},{"location":"spells/#conjuring.spells.pre_commit.auto","title":"<code>auto(c, repo='', bleed=False)</code>","text":"<p>Autoupdate a Git hook or all hooks with the latest tag. Needs fzf and yq.</p> Source code in <code>src/conjuring/spells/pre_commit.py</code> <pre><code>@task()\ndef auto(c: Context, repo: str = \"\", bleed: bool = False) -&gt; None:\n    \"\"\"Autoupdate a Git hook or all hooks with the latest tag. Needs fzf and yq.\"\"\"\n    command = \"\"\n    if repo:\n        chosen = run_with_fzf(c, \"yq e '.repos[].repo' .pre-commit-config.yaml\", query=repo, dry=False)\n        command = f\"--repo {chosen}\"\n    run_command(c, \"pre-commit autoupdate\", \"--bleeding-edge\" if bleed else \"\", command)\n</code></pre>"},{"location":"spells/#conjuring.spells.pre_commit.get_hook_types","title":"<code>get_hook_types(commit_msg, desired_hooks=None)</code>","text":"<p>Prepare a list of hook types to install/uninstall.</p> Source code in <code>src/conjuring/spells/pre_commit.py</code> <pre><code>def get_hook_types(commit_msg: bool, desired_hooks: list[str] | None = None) -&gt; str:\n    \"\"\"Prepare a list of hook types to install/uninstall.\"\"\"\n    hooks = [\"pre-commit\"]\n    if desired_hooks:\n        hooks.extend(desired_hooks)\n    if commit_msg:\n        hooks.append(\"commit-msg\")\n        hooks.append(\"prepare-commit-msg\")\n    return \" \".join([f\"--hook-type {h}\" for h in hooks])\n</code></pre>"},{"location":"spells/#conjuring.spells.pre_commit.install","title":"<code>install(c, before, gc=False, commit_msg=True)</code>","text":"<p>Pre-commit install hooks.</p> Source code in <code>src/conjuring/spells/pre_commit.py</code> <pre><code>@task(\n    help={\n        \"gc\": \"Run the garbage collector to remove unused venvs\",\n        \"commit_msg\": \"Install commit message hooks\",\n        \"before\": \"Config files to run before the current one.\",\n    },\n    iterable=[\"before\"],\n)\ndef install(c: Context, before: list[str], gc: bool = False, commit_msg: bool = True) -&gt; None:\n    \"\"\"Pre-commit install hooks.\"\"\"\n    if gc:\n        _run_garbage_collector(c)\n    c.run(f\"pre-commit install {get_hook_types(commit_msg)} --install-hooks\")\n    if before:\n        _patch_pre_commit_configs(before)\n</code></pre>"},{"location":"spells/#conjuring.spells.pre_commit.run","title":"<code>run(c, hooks)</code>","text":"<p>Pre-commit run all hooks or a specific one. Don't stop on failures. Needs fzf and yq.</p> Source code in <code>src/conjuring/spells/pre_commit.py</code> <pre><code>@task(\n    help={\n        \"hooks\": \"Comma-separated list of partial hook IDs (fzf will be used to match them).\"\n        \" Use 'all', '.' or '-' to run all hooks.\",\n    },\n)\ndef run(c: Context, hooks: str) -&gt; None:\n    \"\"\"Pre-commit run all hooks or a specific one. Don't stop on failures. Needs fzf and yq.\"\"\"\n    split_hooks = hooks.split(\",\")\n    chosen_hooks = []\n    for special in (\"all\", \".\", \"-\"):\n        if special in split_hooks:\n            chosen_hooks.append(\"\")\n            break\n    if not chosen_hooks:\n        chosen_hooks = [\n            run_with_fzf(\n                c,\n                \"yq e '.repos[].hooks[].id' .pre-commit-config.yaml | sort -u\",\n                query=partial_hook,\n                dry=False,\n            )\n            for partial_hook in split_hooks\n        ]\n\n    for chosen_hook in chosen_hooks:\n        run_command(c, \"pre-commit run --all-files\", chosen_hook, warn=True)\n</code></pre>"},{"location":"spells/#conjuring.spells.pre_commit.uninstall","title":"<code>uninstall(c, gc=False, commit_msg=True)</code>","text":"<p>Pre-commit uninstall ALL hooks.</p> Source code in <code>src/conjuring/spells/pre_commit.py</code> <pre><code>@task(help={\"gc\": \"Run the garbage collector to remove unused venvs\", \"commit_msg\": \"Uninstall commit message hooks\"})\ndef uninstall(c: Context, gc: bool = False, commit_msg: bool = True) -&gt; None:\n    \"\"\"Pre-commit uninstall ALL hooks.\"\"\"\n    if gc:\n        _run_garbage_collector(c)\n\n    installed_hooks = [hook for hook in run_stdout(c, \"ls .git/hooks\", dry=False).splitlines() if \".sample\" not in hook]\n    c.run(f\"pre-commit uninstall {get_hook_types(commit_msg, installed_hooks)}\")\n</code></pre>"},{"location":"spells/#conjuring.spells.py","title":"<code>conjuring.spells.py</code>","text":"<p>Python and Poetry.</p> <p>Install venvs, run tests and coverage, install debug tools.</p>"},{"location":"spells/#conjuring.spells.py.Poetry","title":"<code>Poetry</code>  <code>dataclass</code>","text":"<p>Poetry-related tasks.</p> Source code in <code>src/conjuring/spells/py.py</code> <pre><code>@dataclass()\nclass Poetry:\n    \"\"\"Poetry-related tasks.\"\"\"\n\n    context: Context\n\n    def used_in_project(self, display_error: bool = True) -&gt; bool:\n        \"\"\"Check if Poetry is being used.\"\"\"\n        used = int(\n            run_command(\n                self.context,\n                f\"grep tool.poetry {PYPROJECT_TOML} 2&gt;/dev/null | wc -c\",\n                hide=True,\n                warn=True,\n            ).stdout.strip(),\n        )\n        if not used and display_error:\n            print_error(\"This task only works with Poetry projects (so far).\")\n        return bool(used)\n\n    @staticmethod\n    def parse_python_version(venv: str) -&gt; str:\n        \"\"\"For now, assuming we only have Poetry venvs.\"\"\"\n        return venv.split(\" \")[0].split(\"-py\")[1]\n\n    def remove_venv(self, python_version: str) -&gt; Result:\n        \"\"\"Remove a Poetry venv.\"\"\"\n        return self.context.run(f\"poetry env remove python{python_version}\")\n\n    def guess_python_version(self) -&gt; str:\n        \"\"\"Guess Python version from pyproject.toml.\"\"\"\n        # TODO: rewrite this hack and use a TOML package to read the values directly\n        pyproject_lines = run_lines(\n            self.context,\n            f\"rg --no-line-number -e '^python ' -e python_version {PYPROJECT_TOML}\",\n        )\n        versions: set[str] = set()\n        for line in pyproject_lines:\n            value_with_comment = line.split(\"=\")[1]\n            value_only = value_with_comment.split(\"#\")[0]\n            clean_version = value_only.replace(\"^\", \"\").replace(\"~\", \"\").strip('\" ')\n            versions.add(clean_version)\n        if len(versions) &gt; 1:\n            print_error(f\"Multiple Python versions found in {PYPROJECT_TOML}: {versions=}\")\n            raise SystemExit\n        return next(iter(versions))\n\n    def use_venv(self, python_version: str) -&gt; Result:\n        \"\"\"Use a Poetry venv.\"\"\"\n        version_obj = parse(python_version)\n        return self.context.run(f\"poetry env use python{version_obj.major}.{version_obj.minor}\")\n</code></pre>"},{"location":"spells/#conjuring.spells.py.Poetry.guess_python_version","title":"<code>guess_python_version()</code>","text":"<p>Guess Python version from pyproject.toml.</p> Source code in <code>src/conjuring/spells/py.py</code> <pre><code>def guess_python_version(self) -&gt; str:\n    \"\"\"Guess Python version from pyproject.toml.\"\"\"\n    # TODO: rewrite this hack and use a TOML package to read the values directly\n    pyproject_lines = run_lines(\n        self.context,\n        f\"rg --no-line-number -e '^python ' -e python_version {PYPROJECT_TOML}\",\n    )\n    versions: set[str] = set()\n    for line in pyproject_lines:\n        value_with_comment = line.split(\"=\")[1]\n        value_only = value_with_comment.split(\"#\")[0]\n        clean_version = value_only.replace(\"^\", \"\").replace(\"~\", \"\").strip('\" ')\n        versions.add(clean_version)\n    if len(versions) &gt; 1:\n        print_error(f\"Multiple Python versions found in {PYPROJECT_TOML}: {versions=}\")\n        raise SystemExit\n    return next(iter(versions))\n</code></pre>"},{"location":"spells/#conjuring.spells.py.Poetry.parse_python_version","title":"<code>parse_python_version(venv)</code>  <code>staticmethod</code>","text":"<p>For now, assuming we only have Poetry venvs.</p> Source code in <code>src/conjuring/spells/py.py</code> <pre><code>@staticmethod\ndef parse_python_version(venv: str) -&gt; str:\n    \"\"\"For now, assuming we only have Poetry venvs.\"\"\"\n    return venv.split(\" \")[0].split(\"-py\")[1]\n</code></pre>"},{"location":"spells/#conjuring.spells.py.Poetry.remove_venv","title":"<code>remove_venv(python_version)</code>","text":"<p>Remove a Poetry venv.</p> Source code in <code>src/conjuring/spells/py.py</code> <pre><code>def remove_venv(self, python_version: str) -&gt; Result:\n    \"\"\"Remove a Poetry venv.\"\"\"\n    return self.context.run(f\"poetry env remove python{python_version}\")\n</code></pre>"},{"location":"spells/#conjuring.spells.py.Poetry.use_venv","title":"<code>use_venv(python_version)</code>","text":"<p>Use a Poetry venv.</p> Source code in <code>src/conjuring/spells/py.py</code> <pre><code>def use_venv(self, python_version: str) -&gt; Result:\n    \"\"\"Use a Poetry venv.\"\"\"\n    version_obj = parse(python_version)\n    return self.context.run(f\"poetry env use python{version_obj.major}.{version_obj.minor}\")\n</code></pre>"},{"location":"spells/#conjuring.spells.py.Poetry.used_in_project","title":"<code>used_in_project(display_error=True)</code>","text":"<p>Check if Poetry is being used.</p> Source code in <code>src/conjuring/spells/py.py</code> <pre><code>def used_in_project(self, display_error: bool = True) -&gt; bool:\n    \"\"\"Check if Poetry is being used.\"\"\"\n    used = int(\n        run_command(\n            self.context,\n            f\"grep tool.poetry {PYPROJECT_TOML} 2&gt;/dev/null | wc -c\",\n            hide=True,\n            warn=True,\n        ).stdout.strip(),\n    )\n    if not used and display_error:\n        print_error(\"This task only works with Poetry projects (so far).\")\n    return bool(used)\n</code></pre>"},{"location":"spells/#conjuring.spells.py.PyEnv","title":"<code>PyEnv</code>  <code>dataclass</code>","text":"<p>pyenv-related tasks.</p> Source code in <code>src/conjuring/spells/py.py</code> <pre><code>@dataclass\nclass PyEnv:\n    \"\"\"pyenv-related tasks.\"\"\"\n\n    context: Context\n\n    def has_local(self) -&gt; bool:\n        \"\"\"Check if a local Python version is set.\"\"\"\n        output = self.context.run(\"pyenv local\", warn=True).stdout.strip()\n        return output and \"no local version\" not in output\n\n    def set_local(self, python_version: str) -&gt; Result:\n        \"\"\"Set the local pyenv version.\"\"\"\n        latest = self.list_versions(python_version)[-1]\n        return self.context.run(f\"pyenv local {latest}\")\n\n    def list_versions(self, python_version: str | None = None) -&gt; list[str]:\n        \"\"\"List all installed Python versions, or only the ones matching the desired version.\"\"\"\n        all_versions = run_lines(self.context, \"pyenv versions --bare\")\n        if not python_version:\n            return all_versions\n\n        return [version for version in all_versions if version.startswith(python_version)]\n</code></pre>"},{"location":"spells/#conjuring.spells.py.PyEnv.has_local","title":"<code>has_local()</code>","text":"<p>Check if a local Python version is set.</p> Source code in <code>src/conjuring/spells/py.py</code> <pre><code>def has_local(self) -&gt; bool:\n    \"\"\"Check if a local Python version is set.\"\"\"\n    output = self.context.run(\"pyenv local\", warn=True).stdout.strip()\n    return output and \"no local version\" not in output\n</code></pre>"},{"location":"spells/#conjuring.spells.py.PyEnv.list_versions","title":"<code>list_versions(python_version=None)</code>","text":"<p>List all installed Python versions, or only the ones matching the desired version.</p> Source code in <code>src/conjuring/spells/py.py</code> <pre><code>def list_versions(self, python_version: str | None = None) -&gt; list[str]:\n    \"\"\"List all installed Python versions, or only the ones matching the desired version.\"\"\"\n    all_versions = run_lines(self.context, \"pyenv versions --bare\")\n    if not python_version:\n        return all_versions\n\n    return [version for version in all_versions if version.startswith(python_version)]\n</code></pre>"},{"location":"spells/#conjuring.spells.py.PyEnv.set_local","title":"<code>set_local(python_version)</code>","text":"<p>Set the local pyenv version.</p> Source code in <code>src/conjuring/spells/py.py</code> <pre><code>def set_local(self, python_version: str) -&gt; Result:\n    \"\"\"Set the local pyenv version.\"\"\"\n    latest = self.list_versions(python_version)[-1]\n    return self.context.run(f\"pyenv local {latest}\")\n</code></pre>"},{"location":"spells/#conjuring.spells.py.Pytest","title":"<code>Pytest</code>","text":"<p>Pytest-related tasks.</p> Source code in <code>src/conjuring/spells/py.py</code> <pre><code>class Pytest:\n    \"\"\"Pytest-related tasks.\"\"\"\n\n    @staticmethod\n    def command(s: bool) -&gt; str:\n        \"\"\"Build pytest command.\"\"\"\n        command = \"pytest -v\"\n        if s:\n            command += \" -s\"\n        return command\n</code></pre>"},{"location":"spells/#conjuring.spells.py.Pytest.command","title":"<code>command(s)</code>  <code>staticmethod</code>","text":"<p>Build pytest command.</p> Source code in <code>src/conjuring/spells/py.py</code> <pre><code>@staticmethod\ndef command(s: bool) -&gt; str:\n    \"\"\"Build pytest command.\"\"\"\n    command = \"pytest -v\"\n    if s:\n        command += \" -s\"\n    return command\n</code></pre>"},{"location":"spells/#conjuring.spells.py.coverage","title":"<code>coverage(c, show_all=False, s=False)</code>","text":"<p>Run tests with pytest and coverage.</p> Source code in <code>src/conjuring/spells/py.py</code> <pre><code>@task(\n    help={\n        \"show_all\": \"Show all lines, even if they are covered\",\n        \"s\": \"Don't capture output (same shortcut as pytest)\",\n    },\n)\ndef coverage(c: Context, show_all: bool = False, s: bool = False) -&gt; None:\n    \"\"\"Run tests with pytest and coverage.\"\"\"\n    if not Poetry(c).used_in_project():\n        return\n\n    options = [f\"--cov={source}\" for source in [\"src\", Path.cwd().name, \"app\"] if Path(source).exists()]\n\n    skip_option = \"\" if show_all else \":skip-covered\"\n    options.append(f\"--cov-report=term-missing{skip_option}\")\n\n    run_command(c, \"poetry run\", Pytest.command(s), *options)\n</code></pre>"},{"location":"spells/#conjuring.spells.py.debug_tools","title":"<code>debug_tools(c, all_=False, ipython=False, ipdb=False, pudb=False, icecream=False, devtools=False, watch=False, watcher=False)</code>","text":"<p>Install debug tools.</p> Source code in <code>src/conjuring/spells/py.py</code> <pre><code>@task(\n    help={\n        \"all_\": \"Install all debug tools\",\n        \"ipython\": \"Install https://pypi.org/project/ipython/\",\n        \"ipdb\": \"Install https://pypi.org/project/ipdb/\",\n        \"pudb\": \"Install https://pypi.org/project/pudb/\",\n        \"icecream\": \"Install https://pypi.org/project/icecream/\",\n        \"devtools\": \"Install https://pypi.org/project/devtools/\",\n        \"watch\": \"Install https://github.com/joeyespo/pytest-watch\",\n        \"watcher\": \"Install https://github.com/olzhasar/pytest-watcher\",\n    },\n)\ndef debug_tools(  # noqa: PLR0913\n    c: Context,\n    all_: bool = False,\n    ipython: bool = False,\n    ipdb: bool = False,\n    pudb: bool = False,\n    icecream: bool = False,\n    devtools: bool = False,\n    watch: bool = False,\n    watcher: bool = False,\n) -&gt; None:\n    \"\"\"Install debug tools.\"\"\"\n    if not Poetry(c).used_in_project():\n        return\n\n    if watch and watcher:\n        print_error(\"Use only one of --watch and --watcher.\")\n        return\n    if watch:\n        c.run(\"poetry run python -m pip uninstall -y pytest-watcher\")\n    elif watcher:\n        c.run(\"poetry run python -m pip uninstall -y pytest-watch\")\n    tools = [\n        \"pip\",\n        \"ipython\" if ipython or all_ else \"\",\n        \"ipdb\" if ipdb or all_ else \"\",\n        \"pudb\" if pudb or all_ else \"\",\n        \"icecream\" if icecream or all_ else \"\",\n        \"devtools[pygments]\" if devtools or all_ else \"\",\n        \"pytest-watch pytest-testmon\" if watch or all_ else \"\",\n        \"pytest-watcher pytest-testmon\" if watcher or all_ else \"\",\n    ]\n    run_command(c, \"poetry run pip install --upgrade\", *tools)\n</code></pre>"},{"location":"spells/#conjuring.spells.py.editable","title":"<code>editable(c, inject='')</code>","text":"<p>Hack to install a Poetry package as editable until Poetry supports PEP660 hooks.</p> <p>It won't be needed anymore when https://github.com/python-poetry/poetry-core/pull/182 is merged.</p> Source code in <code>src/conjuring/spells/py.py</code> <pre><code>@task(help={\"inject\": \"Pipx repo to inject this project into\"})\ndef editable(c: Context, inject: str = \"\") -&gt; None:\n    \"\"\"Hack to install a Poetry package as editable until Poetry supports PEP660 hooks.\n\n    It won't be needed anymore when https://github.com/python-poetry/poetry-core/pull/182 is merged.\n    \"\"\"\n    if not Poetry(c).used_in_project():\n        return\n\n    chosen_repo = \"\"\n    if inject:\n        # Ask for the repo before doing anything else... to fail fast if no repo is chosen\n        chosen_repo = run_with_fzf(c, \"ls -1 ~/.local/pipx/venvs/\", query=inject)\n        if not chosen_repo:\n            return\n\n    c.run(\"poetry build\")\n    c.run(\"tar -xvzf dist/*.gz --strip-components 1 */setup.py\")\n    # Ignore errors, it might not be installed\n    c.run(\"black setup.py\", warn=True)\n\n    if not chosen_repo:\n        print_error(\"Use --inject to inject this repo into a pipx virtualenv.\")\n        return\n\n    c.run(f\"mv {PYPROJECT_TOML} _{PYPROJECT_TOML}\")\n    run_command(c, \"pipx inject -e\", chosen_repo, \".\")\n    c.run(f\"mv _{PYPROJECT_TOML} {PYPROJECT_TOML}\")\n    c.run(\"rm setup.py\")\n</code></pre>"},{"location":"spells/#conjuring.spells.py.install","title":"<code>install(c, version='', force=False, delete_all=False, pipx=False, editable=False)</code>","text":"<p>Install a Python virtual environment. For now, only works with Poetry.</p> Source code in <code>src/conjuring/spells/py.py</code> <pre><code>@task(\n    help={\n        \"version\": \"Python version\",\n        \"force\": \"Recreate the environment\",\n        \"delete_all\": \"Delete all environments\",\n        \"pipx\": \"Install with pipx\",\n        \"editable\": \"Install as editable\",\n    },\n)\ndef install(  # noqa: PLR0913\n    c: Context,\n    version: str = \"\",\n    force: bool = False,\n    delete_all: bool = False,\n    pipx: bool = False,\n    editable: bool = False,\n) -&gt; None:\n    \"\"\"Install a Python virtual environment. For now, only works with Poetry.\"\"\"\n    venv_list = run_lines(c, \"poetry env list\", hide=False)\n    poetry = Poetry(c)\n    if not poetry.used_in_project():\n        return\n\n    if delete_all:\n        for venv_name in venv_list:\n            if \".venv\" in venv_name:\n                c.run(\"rm -rf .venv\")\n            else:\n                poetry.remove_venv(poetry.parse_python_version(venv_name))\n\n    if not version:\n        version = poetry.guess_python_version()\n    pyenv = PyEnv(c)\n    if force or not pyenv.has_local():\n        # TODO: if tox.ini is present in the repo, set all versions from there\n        pyenv.set_local(version)\n    if force and not delete_all:\n        poetry.remove_venv(version)\n    poetry.use_venv(version)\n\n    c.run(\"poetry lock --check &amp;&amp; poetry install\")\n    if pipx:\n        run_command(c, \"pipx install\", \"--python\", f\"python{version}\", \" --editable\" if editable else \"\", \".\")\n    c.run(\"poetry env list\")\n</code></pre>"},{"location":"spells/#conjuring.spells.py.test","title":"<code>test(c, s=False)</code>","text":"<p>Run tests with pytest.</p> Source code in <code>src/conjuring/spells/py.py</code> <pre><code>@task(\n    help={\n        \"s\": \"Don't capture output (same shortcut as pytest)\",\n    },\n)\ndef test(c: Context, s: bool = False) -&gt; None:\n    \"\"\"Run tests with pytest.\"\"\"\n    if not Poetry(c).used_in_project():\n        return\n\n    run_command(c, \"poetry run\", Pytest.command(s))\n</code></pre>"},{"location":"spells/#conjuring.spells.py.watch","title":"<code>watch(c)</code>","text":"<p>Watch changed files and run tests with pytest.</p> Source code in <code>src/conjuring/spells/py.py</code> <pre><code>@task\ndef watch(c: Context) -&gt; None:\n    \"\"\"Watch changed files and run tests with pytest.\"\"\"\n    if not Poetry(c).used_in_project():\n        return\n\n    run_command(c, \"poetry run\", \"ptw . --testmon\")\n</code></pre>"},{"location":"spells/#conjuring.spells.shell","title":"<code>conjuring.spells.shell</code>","text":"<p>Shell: install/uninstall completion.</p>"},{"location":"spells/#conjuring.spells.shell.completion_install","title":"<code>completion_install(c, app)</code>","text":"<p>Install shell completion. For now, only for the Bash shell, and only for Click projects.</p> <ul> <li>Shell Completion \u2014 Click Documentation (8.0.x)</li> <li>click-contrib/click-completion: Add or enhance bash, fish, zsh and powershell completion in Click</li> </ul> Source code in <code>src/conjuring/spells/shell.py</code> <pre><code>@task\ndef completion_install(c: Context, app: str) -&gt; None:\n    \"\"\"Install shell completion. For now, only for the Bash shell, and only for Click projects.\n\n    - [Shell Completion \u2014 Click Documentation (8.0.x)](https://click.palletsprojects.com/en/8.0.x/shell-completion/)\n    - [click-contrib/click-completion: Add or enhance bash, fish, zsh and powershell completion in Click](https://github.com/click-contrib/click-completion)\n    \"\"\"\n    completion_file = f\"{COMPAT_DIR}{app}.bash-completion\"\n    c.run(f\"_{app.upper()}_COMPLETE=bash_source {app} &gt; {completion_file}\")\n    c.run(f\"eza -l {completion_file}\")\n    c.run(f\"bat {completion_file}\")\n</code></pre>"},{"location":"spells/#conjuring.spells.shell.completion_list","title":"<code>completion_list(c)</code>","text":"<p>List existing shell completions.</p> Source code in <code>src/conjuring/spells/shell.py</code> <pre><code>@task\ndef completion_list(c: Context) -&gt; None:\n    \"\"\"List existing shell completions.\"\"\"\n    for var in COMPLETION_DIRS:\n        c.run(f\"eza -l {var}\")\n</code></pre>"},{"location":"spells/#conjuring.spells.shell.completion_uninstall","title":"<code>completion_uninstall(c, app)</code>","text":"<p>Uninstall shell completion from both completion dirs.</p> Source code in <code>src/conjuring/spells/shell.py</code> <pre><code>@task\ndef completion_uninstall(c: Context, app: str) -&gt; None:\n    \"\"\"Uninstall shell completion from both completion dirs.\"\"\"\n    for completion_dir in COMPLETION_DIRS:\n        with c.cd(completion_dir):\n            c.run(f\"rm -v {app}*\", warn=True)\n    completion_list(c)\n</code></pre>"}]}